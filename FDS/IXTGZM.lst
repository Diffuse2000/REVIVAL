Microsoft (R) Macro Assembler Version 14.15.26730.0	    10/31/18 01:22:14
C:\Projects\REVIVAL\FDS\FILLERS\IXTGZM.ASM		     Page 1 - 1


				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;; CODING LOG
				;; fabricators operative 29.06.02
				;; interpolation levels -
				;;	level 0 - preprocessing
				;;	level 1 - outer/outer (ngon)
				;;	level 2 - outer/inner (section)
				;;	level 3 - inner/outer (span)
				;;	level 4 - inner/inner (interval)
				;; 29.06.02 mapper works with the following characteristics
				;;		flat spanloop. 
				;;		interpolation level: ZBuffer:1, Gouraud:2, Texture:2.
				;; Current: spanloop preperations / interface definition
				;; 02.07.02
				;;		gouraud zbuffer spanloop.
				;;		interpolation level: ZBuffer:4, Gouraud:4, Texture:2.
				;;		ZBuffer interpolation errors
				;; 03.07.02 corrections
				;; - added interpolation across span sections
				;; - corrected variable ordering for constant d/dX
				;; - corrected x prestepping
				;; - corrected gouraud interpolation innerloop on nodraw
				;; - zBuffering operational
				;; - zBuffering has precision problems
				;; 22.07.02
				;; + fixed a bug in subspan d[uv]dx (used psubw instead of psubd!!) 
				;;  - total work = 12 coder hours
				;; - interpolation level: ZBuffer:4, Gouraud:4, Texture:4.
				;; + added self-modifying code support
				;;  - mapper works on all rectangular textures up to 256x256.
				;; 26.07.02
				;; + add support for generic texture block scribbling 
				;;	- inner/outer, write mask update code + SMC
				;;	- inner/inner, write mask update SMC
				;;
				;; TODO list
				;; - block scribbling fixed for block size 4x4, replace with more generic code?
				;;   or at least check if 4x8,8x4, or 8x8 work faster.
				;; - precision correction: use a N-R iteration
				;;   x=rcpss(y), x = x+x - y*x*x;  (or: x += x*(1-y*x))
				;; - test removal of (u,v) update within inner/outer. 
				;;   this will cause error of (3 + log(#spans))bit in the fractional coordinate.
				;;	 using small fixups, expected error can be reduced to 
				;;   (3 + log(log(#spans)) bits.
				;; + test robustness of wBuffer vs zBuffer.
				;;  - zBuffer sucks because of range errors
				;;  - wBuffer sucks because of lousy distribution of values
				;;  - integer z and dzdx should have 19-20 bit precision within inner/inner because
				;;	  the accumulated error along 16 pixel span screws up 3 or so least bits.
				;;	  could use adc or rotations to do it, 
				;;  - need fixup for last <16 pixel span, sampling the z(x) hyperbola outside the polygon can
				;;	  cause z values to get completely out of range.

				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;; ASSEMBLER VERSION OF THE IX MAPPER ;;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;										;;
				;	Highly optimized texture/gouraud     ;
				;   mapper using PentiumIII w/ SSE		 ;
				;		Supports Z-buffering			 ;
				;;										;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;; All rights reserved to Flood corp. ;;;
				;;; (diffuse, silvatar, and buffer)    ;;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

				;;; ASSEMBLER DIRECTIVES ;;;
				.686
				.MMX
				.XMM

 00000000			_DATA   SEGMENT PARA PUBLIC 'DATA'
				align 16

				;;; Left/Right Section ;;;
					extrn	_VESA_BPSL		:	DWORD
					extrn	_PageSize		:	DWORD
					extrn	_XRes			:	DWORD
					extrn   _g_zscale256	:	DWORD
					extrn	_g_zscale		:	DWORD

					;;; Left section
 00000000 00000000			Left_RZ			dd		0.0
 00000004 00000000			Left_UZ			dd		0.0
 00000008 00000000			Left_VZ			dd		0.0
 0000000C 00000000			Left_X			dd		0.0
									
 00000010 00000000			Left_dRZ		dd		0.0
 00000014 00000000			Left_dUZ		dd		0.0
 00000018 00000000			Left_dVZ		dd		0.0
 0000001C 00000000			Left_dX			dd		0.0
									
 00000020 00000000			Left_R			dd		0.0
 00000024 00000000			Left_G			dd		0.0
 00000028 00000000			Left_B			dd		0.0
 0000002C 00000000			Left_A			dd		0.0
									
 00000030 00000000			Left_dR			dd		0.0
 00000034 00000000			Left_dG			dd		0.0
 00000038 00000000			Left_dB			dd		0.0
 0000003C 00000000			Left_dA			dd		0.0
									
					; Right section
 00000040 00000000			Right_R			dd		0.0
 00000044 00000000			Right_G			dd		0.0
 00000048 00000000			Right_B			dd		0.0
 0000004C 00000000			Right_A			dd		0.0

 00000050 00000000			Right_dR		dd		0.0
 00000054 00000000			Right_dG		dd		0.0
 00000058 00000000			Right_dB		dd		0.0
 0000005C 00000000			Right_dA		dd		0.0

					; Constant deltas over X
 00000060 00000000			_dRZdx		dd		0.0
 00000064 00000000			_dUZdx		dd		0.0
 00000068 00000000			_dVZdx		dd		0.0	
 0000006C 00000000			_filler1	dd		0.0
					; Scaled deltas over X
					;_sdRZdx		dd		0.0
					;_sdUZdx		dd		0.0
					;_sdVZdx		dd		0.0	
					;_filler2	dd		0.0
					; Lighting deltas over X for current scan line
 00000070 0000				_dRdx		dw		0
 00000072 0000				_dGdx		dw		0
 00000074 0000				_dBdx		dw		0
 00000076 0000				_dAdx		dw		0


				; innerloop variables (cacheline 0)
 00000078 00000000			dudx			dd		0
 0000007C 00000000			dvdx			dd		0
 00000080 00000000			SubspanZ		dd		0
 00000084 00000000			SubspanCounter	dd		0
 00000088 00000000			Right_X			dd		0.0
 0000008C 00000000			Right_dX		dd		0.0
 00000090 00000000			save_esp		dd		0
 00000094 00000000			align32			dd		0

				; innerloop variables (cacheline 1)

				; outerloop variables (cacheline 0? this isn't aligned)
 00000098 00000000			Left_Height		dd		0.0
 0000009C 00000000			Left_ScanLines	dd		0
 000000A0 00000000			Left_Vert		dd		0

 000000A4 00000000			Right_Height	dd		0.0
 000000A8 00000000			Right_rHeight	dd		0.0
 000000AC 00000000			Right_ScanLines	dd		0
 000000B0 00000000			Right_Vert		dd		0
 000000B4 00000000			Right_Size		dd		0

 000000B8 00000000			_SectionHeight	dd		0
 000000BC 00000000			_HeightCounter  dd		0

				; nonaligned variable region
 000000C0 00000000			LastLogWidth	dd		0
 000000C4 00000000			LastLogHeight	dd		0
 000000C8 00000000			SubSpanWidth	dd		0
 000000CC 00000000			_tebp			dd		0
 000000D0 00000000			t_edi			dd		0


 000000D4 00000000			_Page		dd		0
 000000D8 00000000			_L2Size		dd		0
 000000DC 00000000			_ZBuffer	dd		0
 000000E0 00000000			_Verts		dd		0
 000000E4 00000000			_Texture	dd		0

 = 00000004				_L2SPANSIZE	equ		4
 = 00000010				_SPANSIZE	equ		16
 = f16					_fSPANSIZE	equ		f16
 = pf16					_pfSPANSIZE	equ		pf16

				; Float tables
				align	16

				;	mask tables for standard textures (1x1 blocks)
 000000F0 00010000			_T0		dd		000010000h,
	   00030000
	   00070000
	   000F0000
	   001F0000
	   003F0000
	   007F0000
	   00FF0000
									000030000h,
									000070000h,
									0000f0000h,
									0001f0000h,
									0003f0000h,
									0007f0000h,
									000ff0000h,

 00000110 FFFE8000			_T1		dd		0fffe8000h,
	   FFFC8000
	   FFF88000
	   FFF08000
	   FFE08000
	   FFC08000
	   FF808000
	   FF008000
									0fffc8000h,
									0fff88000h,
									0fff08000h,
									0ffe08000h,
									0ffc08000h,
									0ff808000h,
									0ff008000h


				;	mask tables for tiled textures (4x4 blocks - 2 bits for inner tile position)
 00000130 00000000			_TB0	dd		00000000000000000000000000000000b,
	   00000000
	   00040000
	   000C0000
	   001C0000
	   003C0000
	   007C0000
	   00FC0000
									00000000000000000000000000000000b,
									00000000000001000000000000000000b,
									00000000000011000000000000000000b,
									00000000000111000000000000000000b,
									00000000001111000000000000000000b,
									00000000011111000000000000000000b,
									00000000111111000000000000000000b


 00000150 00008000			_TB1 	dd		00000000000000001000000000000000b,
	   000C8000
	   001C8000
	   003C8000
	   007C8000
	   00FC8000
	   01FC8000
	   03FC8000
									00000000000011001000000000000000b,
									00000000000111001000000000000000b,
									00000000001111001000000000000000b,
									00000000011111001000000000000000b,
									00000000111111001000000000000000b,
									00000001111111001000000000000000b,
									00000011111111001000000000000000b

 00000170 00008000			_TB2	dd		00000000000000001000000000000000b,
	   FFF38000
	   FFE38000
	   FFC38000
	   FF838000
	   FF038000
	   FE038000
	   FC038000
									11111111111100111000000000000000b,
									11111111111000111000000000000000b,
									11111111110000111000000000000000b,
									11111111100000111000000000000000b,
									11111111000000111000000000000000b,
									11111110000000111000000000000000b,
									11111100000000111000000000000000b


 = pf65536				f65536	equ		pf65536
 00000190 47800000			pf65536	dd		65536.0, 65536.0, 65536.0, 65536.0
	   47800000
	   47800000
	   47800000
 000001A0 47000000			pf32768	dd		32768.0, 32768.0, 32768.0, 32768.0
	   47000000
	   47000000
	   47000000
 = pf256				f256	equ		pf256
 000001B0 43800000			pf256	dd		256.0, 256.0, 256.0, 256.0
	   43800000
	   43800000
	   43800000
 000001C0 43000000			pf128	dd		128.0, 128.0, 128.0, 128.0
	   43000000
	   43000000
	   43000000
 = pf16					f16		equ		pf16
 000001D0 41800000			pf16	dd		16.0, 16.0, 16.0, 16.0
	   41800000
	   41800000
	   41800000
 000001E0 3D800000			prf16	dd		0.0625, 0.0625, 0.0625, 0.0625
	   3D800000
	   3D800000
	   3D800000
 000001F0 00000000			pf0		dd		0.0, 0.0, 0.0, 0.0
	   00000000
	   00000000
	   00000000
 00000200 3F800000			f1		dd		1.0	

				align 16
 00000210				DivTable:
					; reciporal table (rf0[x] == 1/x)
 00000210 00000000			rf0		dd		0.0,0.0,0.0,0.0
	   00000000
	   00000000
	   00000000
 00000220 3F800000			rf1		dd		1.0,1.0,1.0,1.0
	   3F800000
	   3F800000
	   3F800000
 00000230 3F000000			rf2		dd 		0.5,0.5,0.5,0.5
	   3F000000
	   3F000000
	   3F000000
 00000240 3EAAAA9F			rf3		dd		0.333333,0.333333,0.333333,0.333333
	   3EAAAA9F
	   3EAAAA9F
	   3EAAAA9F
 00000250 3E800000			rf4		dd		0.25,0.25,0.25,0.25
	   3E800000
	   3E800000
	   3E800000
 00000260 3E4CCCCD			rf5		dd		0.2,0.2,0.2,0.2
	   3E4CCCCD
	   3E4CCCCD
	   3E4CCCCD
 00000270 3E2AAAAB			rf6		dd		0.16666667,0.16666667,0.16666667,0.16666667
	   3E2AAAAB
	   3E2AAAAB
	   3E2AAAAB
 00000280 3E124925			rf7		dd		0.142857142857,0.142857142857,0.142857142857,0.142857142857
	   3E124925
	   3E124925
	   3E124925
 00000290 3E000000			rf8		dd		0.125,0.125,0.125,0.125
	   3E000000
	   3E000000
	   3E000000
 000002A0 3DE38E39			rf9		dd		0.11111111,0.11111111,0.11111111,0.11111111
	   3DE38E39
	   3DE38E39
	   3DE38E39
 000002B0 3DCCCCCD			rf10	dd		0.1,0.1,0.1,0.1
	   3DCCCCCD
	   3DCCCCCD
	   3DCCCCCD
 000002C0 3DBA2E8C			rf11	dd		0.09090909091,0.09090909091,0.09090909091,0.09090909091
	   3DBA2E8C
	   3DBA2E8C
	   3DBA2E8C
 000002D0 3DAAAAAA			rf12	dd		0.08333333,0.08333333,0.08333333,0.08333333
	   3DAAAAAA
	   3DAAAAAA
	   3DAAAAAA
 000002E0 3D9D89CE			rf13	dd		0.076923,0.076923,0.076923,0.076923
	   3D9D89CE
	   3D9D89CE
	   3D9D89CE
 000002F0 3D92495E			rf14	dd		0.071429,0.071429,0.071429,0.071429
	   3D92495E
	   3D92495E
	   3D92495E
 00000300 3D888889			rf15	dd		0.06666667,0.06666667,0.06666667,0.06666667
	   3D888889
	   3D888889
	   3D888889
 00000310 3D800000			rf16	dd		0.0625,0.0625,0.0625,0.0625
	   3D800000
	   3D800000
	   3D800000
 00000320 3D70F0E9			rf17	dd		0.0588235,0.0588235,0.0588235,0.0588235
	   3D70F0E9
	   3D70F0E9
	   3D70F0E9
 00000330 3D638EB0			rf18	dd		0.055556,0.055556,0.055556,0.055556
	   3D638EB0
	   3D638EB0
	   3D638EB0
 00000340 3D5794A7			rf19	dd		0.052632,0.052632,0.052632,0.052632
	   3D5794A7
	   3D5794A7
	   3D5794A7
				;	rf20	dd		0.05,0.05,0.05,0.05
				 
					; Integer division table (lock and load)
 = ri1 - 4				RITable equ		ri1 - 4
 00000350 FFFFFFFF			ri1		dd		0ffffffffh
 00000354 80000000			ri2		dd	    080000000h
 00000358 55555555			ri3		dd		055555555h
 0000035C 40000000			ri4		dd		040000000h
 00000360 33333333			ri5		dd		033333333h
 00000364 2AAAAAAA			ri6		dd		02AAAAAAAh
 00000368 24924924			ri7		dd		024924924h
 0000036C 20000000			ri8		dd		020000000h
 00000370 1C71C71C			ri9		dd		01C71C71Ch
 00000374 19999999			ri10	dd		019999999h
 00000378 1745D174			ri11	dd		01745D174h
 0000037C 15555555			ri12	dd		015555555h
 00000380 13B13B13			ri13	dd		013B13B13h
 00000384 12492492			ri14	dd		012492492h
 00000388 11111111			ri15	dd		011111111h
 0000038C 10000000			ri16	dd		010000000h

					; assorted values (debug)
 00000390 00FFFFFF			whitecolor dd	0ffffffh

					; Vertex Structure
 = 00000000				Vertex_RZ	equ		0h
 = 00000004				Vertex_UZ	equ		4h
 = 00000008				Vertex_VZ	equ		8h
 = 0000000C				Vertex_X	equ		0Ch
 = 00000010				Vertex_R	equ		10h
 = 00000014				Vertex_G	equ		14h
 = 00000018				Vertex_B	equ		18h
 = 0000001C				Vertex_A	equ		1Ch
 = 00000020				Vertex_Y	equ		20h
 = 00000030				VertexSize	equ		30h


				;;; STATIC VARIABLES ;;;

					public			_IX_TGZM_Code_Start
					public			_IX_TGZM_Code_Size
 00000394 00000000 R			_IX_TGZM_Code_Start	dd	ASM_FILE_START
 00000398 000006C3			_IX_TGZM_Code_Size	dd	ASM_FILE_END - ASM_FILE_START

				;;; CODE SEGMENTS ;;;

				align 1
 039C				_DATA   ENDS

 00000000			_TEXT   SEGMENT PARA PUBLIC 'CODE'
					ASSUME  cs:_TEXT, ds:_DATA

				;;; EXPORTED VARIABLES ;;;

				public _IX_TGZM_AsmFiller

 00000000 = 00000000		ASM_FILE_START	equ	$

				;;;;;;;;;;;
				;
				; Purpose:		Calculate right section of the n-gon
				; Arguments:	esi - V1
				;				edi	- V2
				; Returns:		Number of scan lines
				;;;;;;;;;;;
 00000000			TGZM_CalcRightSection	proc	near

 = esi					V1		equ		esi
 = edi					V2		equ		edi

 00000000  53				push ebx

				; calc integer number of scanlines
 00000001  F3/ 0F 10 46			movss	xmm0,	dword ptr [V1 + Vertex_Y]
	   20
 00000006  F3/ 0F 10 4F			movss	xmm1,	dword ptr [V2 + Vertex_Y]
	   20
 0000000B  F3/ 0F 2D D8			cvtss2si ebx,	xmm0
 0000000F  F3/ 0F 2D C1			cvtss2si eax,	xmm1
 00000013  2B C3			sub		eax,	ebx
 00000015  A3 000000AC R		mov		[Right_ScanLines], eax

				; return if scanlines = 0
 0000001A  74 71			jz		JmpRet
				; xmm1 = float height
 0000001C  F3/ 0F 5C C8			subss	xmm1,	xmm0
				; calculate xmm2 = 1.0/height
				; should consider revising using rcpss
 00000020  F3/ 0F 10 15			movss   xmm2,	[f1]
	   00000200 R

				; forward loading of vertex lighting
 00000028  0F 28 67 10			movaps	xmm4, [V2 + Vertex_R]

 0000002C  F3/ 0F 5E D1			divss	xmm2,	xmm1
				;	rcpss	xmm2,	xmm1

				; forward loading of vertex X	xmm0 = V1 X
 00000030  F3/ 0F 10 46			movss	xmm0,	dword ptr [V1 + Vertex_X]
	   0C


				; Right.dX = (V2->X - V1->X) * rHeight;
				; sdword FPRevHeight;

 00000035  F3/ 0F 10 5F			movss  xmm3,   dword ptr [V2 + Vertex_X]
	   0C
 0000003A  F3/ 0F 5C D8			subss	xmm3,	xmm0

				; forward loading of vertex lighting
 0000003E  0F 28 6E 10			movaps	xmm5,	dword ptr [V1 + Vertex_R]

				; xmm3 now contains X delta
 00000042  F3/ 0F 59 DA			mulss   xmm3,	xmm2

				; shuffle xmm2 = 1.0/height
 00000046  0F C6 D2 00			shufps	xmm2,	xmm2,	00000000b

				; Right.dR = (V2->R - V1->R) * RevHeight;
				; Right.dG = (V2->G - V1->G) * RevHeight;
				; Right.dB = (V2->B - V1->B) * RevHeight;
				; Right.dA = (V2->A - V1->A) * RevHeight;
				; xmm4 - V2 Light	xmm5 - V1 Light
 0000004A  0F 5C E5			subps	xmm4,	xmm5
				; xmm4 = RGBA Deltas
 0000004D  0F 59 E2			mulps   xmm4,	xmm2

				;float prestep = ((float)iy1 - V1->Y);
				; Right.X  = V1->X  + Left.dX  * prestep;
				; Right.UZ = V1->UZ + Left.dUZ * prestep;
				; Right.VZ = V1->VZ + Left.dVZ * prestep;
				; Right.RZ = V1->RZ + Left.dRZ * prestep;

				; ebx = ceil(V1->Y)
 00000050  F3/ 0F 2A CB			cvtsi2ss	xmm1,	ebx
				; load V1 X
 00000054  F3/ 0F 5C 4E			subss		xmm1,	dword ptr [V1 + Vertex_Y]
	   20
 00000059  F3/ 0F 10 F1			movss		xmm6,	xmm1
 0000005D  0F C6 F6 00			shufps		xmm6,	xmm6,	00000000b
				; multiply delta (xmm3) by prestep (xmm1)
 00000061  F3/ 0F 59 CB			mulss		xmm1,	xmm3
				; xmm0 = prestepped X
 00000065  F3/ 0F 58 C1			addss		xmm0,	xmm1
					
				; Left.R = V1->R + prestep * Left.dR;
				; Left.G = V1->G + prestep * Left.dG;
				; Left.B = V1->B + prestep * Left.dB;
				; Left.A = V1->A + prestep * Left.dA;
				; xmm5 = V1 Light	xmm6 - prestep	xmm4 - RGBA deltas
 00000069  0F 59 F4			mulps		xmm6,	xmm4
				; xmm5 = prestepped RGBA
 0000006C  0F 58 EE			addps		xmm5,	xmm6
					

				; late storing of X and delta
 0000006F  F3/ 0F 11 05			movss	[Right_X],	xmm0
	   00000088 R
 00000077  F3/ 0F 11 1D			movss	[Right_dX],	xmm3
	   0000008C R

 0000007F  0F 29 2D			movaps	[Right_R],	xmm5
	   00000040 R
 00000086  0F 29 25			movaps	[Right_dR],	xmm4
	   00000050 R
				; multiply RGBA(xmm5), dRGBA(xmm4) by 65536.0 for fixed point
				; and store as RGBA(mm0, mm1) and dRGBA(mm2, mm3)
				;	movaps  xmm0,	[f65536]
				;	mulps	xmm5,	xmm0
				;	mulps	xmm4,	xmm0
				;	cvtps2pi mm1,	xmm5
				;	cvtps2pi mm3,	xmm4
				;	movhlps	xmm4,	xmm4
				;	movhlps	xmm5,	xmm5
				;	cvtps2pi mm0,	xmm5
				;	cvtps2pi mm2,	xmm4

				;	movq qword ptr [Right_R],	mm0
				;	movq qword ptr [Right_B],	mm1
				;	movq qword ptr [Right_dR],	mm2
				;	movq qword ptr [Right_dB],	mm3


 0000008D			JmpRet:
 0000008D  5B				pop ebx
 0000008E  C3				ret

 0000008F			TGZM_CalcRightSection	endp


				;;;;;;;;;;;
				;
				; Purpose:		Calculate left section of the n-gon
				; Arguments:	esi - IXVertex *V1
				;				edi	- IXVertex *V2
				; Returns:		Number of scan lines
				;;;;;;;;;;;
 0000008F			TGZM_CalcLeftSection		proc	near

 = esi					V1		equ		esi
 = edi					V2		equ		edi

 0000008F  53				push ebx

				; calc integer number of scanlines
 00000090  F3/ 0F 10 46			movss	xmm0,	dword ptr [V1 + Vertex_Y]
	   20
 00000095  F3/ 0F 10 4F			movss	xmm1,	dword ptr [V2 + Vertex_Y]
	   20
 0000009A  F3/ 0F 2D D8			cvtss2si ebx,	xmm0
 0000009E  F3/ 0F 2D C1			cvtss2si eax,	xmm1
 000000A2  2B C3			sub		eax,	ebx
 000000A4  A3 0000009C R		mov		[Left_ScanLines], eax

				; return if scanlines = 0
 000000A9  74 66			jz		JmpRet
				; xmm1 = float height
 000000AB  F3/ 0F 5C C8			subss	xmm1,	xmm0

				; should consider revising using rcpss
				; calculate xmm2 = 1.0/height
 000000AF  F3/ 0F 10 15			movss   xmm2,	[f1]
	   00000200 R

				; forward loading of vertex lighting
 000000B7  0F 28 67 10			movaps	xmm4, [V2 + Vertex_R]

 000000BB  F3/ 0F 5E D1			divss	xmm2,	xmm1
				;	rcpss	xmm2,	xmm1

				; forward loading of vertex ZUVX	xmm0 = V1 ZUVX
 000000BF  0F 28 06			movaps	xmm0,	[V1 + Vertex_RZ]


				; IX.Left.dX = (V2->X - V1->X) * RevHeight;
				; IX.Left.dUZ = (V2->UZ - V1->UZ) * RevHeight;
				; IX.Left.dVZ = (V2->VZ - V1->VZ) * RevHeight;
				; IX.Left.dRZ = (V2->RZ - V1->RZ) * RevHeight;

 000000C2  0F 28 1F			movaps  xmm3,   [V2 + Vertex_RZ]
 000000C5  0F 5C D8			subps	xmm3,	xmm0

				; shuffle xmm2 = 1.0/height
 000000C8  0F C6 D2 00			shufps	xmm2,	xmm2,	00000000b

				; forward loading of vertex lighting
 000000CC  0F 28 6E 10			movaps	xmm5,	[V1 + Vertex_R]

				; xmm3 now contains XUVZ deltas	
 000000D0  0F 59 DA			mulps   xmm3,	xmm2

				; Left.dR = (V2->R - V1->R) * RevHeight;
				; Left.dG = (V2->G - V1->G) * RevHeight;
				; Left.dB = (V2->B - V1->B) * RevHeight;
				; Left.dA = (V2->A - V1->A) * RevHeight;
				; xmm4 - V2 Light	xmm5 - V1 Light
 000000D3  0F 5C E5			subps	xmm4,	xmm5
				; xmm4 = RGBA Deltas
 000000D6  0F 59 E2			mulps   xmm4,	xmm2

				;float prestep = ((float)iy1 - V1->Y);
				; Left.X  = V1->X  + Left.dX  * prestep;
				; Left.UZ = V1->UZ + Left.dUZ * prestep;
				; Left.VZ = V1->VZ + Left.dVZ * prestep;
				; Left.RZ = V1->RZ + Left.dRZ * prestep;

				; ebx = ceil(V1->Y)
 000000D9  F3/ 0F 2A CB			cvtsi2ss	xmm1,	ebx
				; load V1 XUVZ
 000000DD  F3/ 0F 5C 4E			subss		xmm1,	dword ptr [V1 + Vertex_Y]
	   20
 000000E2  0F C6 C9 00			shufps		xmm1,	xmm1,	00000000b
 000000E6  0F 28 F1			movaps		xmm6,	xmm1
				; multiply deltas (xmm3) by prestep (xmm1)
 000000E9  0F 59 CB			mulps		xmm1,	xmm3
				; xmm0 = prestepped XUVZ
 000000EC  0F 58 C1			addps		xmm0,	xmm1
					
				; Left.R = V1->R + prestep * Left.dR;
				; Left.G = V1->G + prestep * Left.dG;
				; Left.B = V1->B + prestep * Left.dB;
				; Left.A = V1->A + prestep * Left.dA;
				; xmm5 = V1 Light	xmm6 - prestep	xmm4 - RGBA deltas
 000000EF  0F 59 F4			mulps		xmm6,	xmm4
				; xmm5 = prestepped RGBA
 000000F2  0F 58 EE			addps		xmm5,	xmm6

				; late storing of XUVZ and deltas (yesh)
 000000F5  0F 29 05			movaps	[Left_RZ],	xmm0
	   00000000 R
 000000FC  0F 29 1D			movaps	[Left_dRZ],	xmm3
	   00000010 R

 00000103  0F 29 2D			movaps	[Left_R],	xmm5
	   00000020 R
 0000010A  0F 29 25			movaps	[Left_dR],	xmm4
	   00000030 R
				; multiply RGBA(xmm5), dRGBA(xmm4) by 65536.0 for fixed point
				; and store as RGBA(mm0, mm1) and dRGBA(mm2, mm3)
				;	movaps  xmm0,	[f65536]
				;	mulps	xmm5,	xmm0
				;	mulps	xmm4,	xmm0
				;	cvtps2pi mm1,	xmm5
				;	cvtps2pi mm3,	xmm4
				;	movhlps	xmm4,	xmm4
				;	movhlps	xmm5,	xmm5
				;	cvtps2pi mm0,	xmm5

				;	cvtps2pi mm2,	xmm4
				;
				;	movq qword ptr [Left_R],	mm0
				;	movq qword ptr [Left_B],	mm1
				;	movq qword ptr [Left_dR],	mm2
				;	movq qword ptr [Left_dB],	mm3

 00000111			JmpRet:
 00000111  5B				pop ebx
 00000112  C3				ret

 00000113			TGZM_CalcLeftSection		endp


				;	Summery: Span loop Input
				;	mm0, mm1:	RGB, delta
				;	ebx:		span width
				;	edi:		span ptr
				;	esi:		Zbuffer ptr
				;	xmm0:		ZUVX initial left
				;	xmm2:		ZUVX constant d/dx
 00000113			TGZM_SpanLoop			proc	near

					; Flat inner
				comment &
					mov ecx, ebx
					mov eax, 07f7f7f7fh
					rep stosd
					ret
				&

					; WE ARE FUCK'N OUT OF FREE REGISTERS!!!
					; so we use esp as a replacement.
					; why? because we can.
					; DOS INCOMPATIBLE

 00000113  89 25 00000090 R		mov [save_esp],esp
 00000119  8B E7			mov esp,edi
				;	mov [t_edi], edi

					; releases ebx.
 0000011B  89 1D 00000084 R		mov [SubspanCounter], ebx
					
					; logic
					; z = 1/interpolated rz
					; Z = 0xFF80 - Fist(g_zscale * z);

					; allocation
					; xmm4 = z
					; eax = Z, edx = dZdx
 00000121  B8 0000FF80			mov			eax,	0ff80h

 00000126  F3/ 0F 53 C8			rcpss		xmm1,	xmm0
				;	movss		xmm1,	[f1]
				;	divss		xmm1,	xmm0

 0000012A  F3/ 0F 10 E1			movss		xmm4,	xmm1
 0000012E  F3/ 0F 59 0D			mulss		xmm1,	_g_zscale
	   00000000 E
 00000136  F3/ 0F 2D D9			cvtss2si	ebx,	xmm1
 0000013A  2B C3			sub			eax,	ebx

					; xmm4, xmm7 = UV affine (16bit fractional)
 0000013C  F3/ 0F 10 2D			movss		xmm5,	[pf65536]
	   00000190 R
 00000144  F3/ 0F 59 E5			mulss		xmm4,	xmm5
 00000148  0F C6 E4 00			shufps		xmm4,	xmm4,	00000000b
 0000014C  0F 59 E0			mulps		xmm4,	xmm0
 0000014F  0F C6 E4 09			shufps		xmm4,	xmm4,	00001001b
 00000153  0F 28 FC			movaps		xmm7,	xmm4

					; mm2 = [Ui:Uf]        [Vi:Vf] (frees xmm4)
					; ebp = [Ui:Uf], edi = [Vi:Vf] (frees mm2)
 00000156  0F 2D D4			cvtps2pi	mm2,	xmm4


				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;; placeholder: ebp/edi init
					; ebp = u wwww ww00 0000 00ww 0fff ffff ffff ffff
 00000159  0F 7E D7			movd		edi,	mm2
					
 0000015C  81 E7 00FC0000		and			edi,	000fc0000h		; TB0(logWidth)
					org			$-4
 0000015E 00FC0000			smc_TB0Wd0	dd		000fc0000h

 00000162  C1 E7 08			shl			edi,	8				; logHeight
					org			$-1
 00000164 08				smc_Hb0		db		8
					
 00000165  0F 7E D5			movd		ebp,	mm2
 00000168  0F 7E D3			movd		ebx,	mm2
 0000016B  D1 ED			shr			ebp,	1
 0000016D  81 E3 00030000		and			ebx,	000030000h
 00000173  0B DF			or			ebx,	edi
 00000175  81 E5 00007FFF		and			ebp,	07fffh
 0000017B  0B EB			or			ebp,	ebx	

 0000017D  0F 70 D2 4E			pshufw		mm2,	mm2,	01001110b

					; edi = v 0000 00ww wwww ww00 0fff ffff ffff ffff
 00000181  0F 7E D7			movd		edi,	mm2
 00000184  0F 7E D3			movd		ebx,	mm2
 00000187  D1 EF			shr			edi,	1	
					
 00000189  81 E3 00FF0000		and			ebx,	000ff0000h      ; T0(logHeight)
					org			$-4
 0000018B 00FF0000			smc_T0Hd0	dd		000ff0000h

 0000018F  03 DB			add			ebx,	ebx
 00000191  03 DB			add			ebx,	ebx
					
 00000193  81 E7 00007FFF		and			edi,	07fffh
 00000199  0B FB			or			edi,	ebx

 0000019B  0F 70 D2 4E			pshufw		mm2,	mm2,	01001110b

 0000019F			Outer:

					; Compute current sub-span width
 0000019F  B9 00000010			mov			ecx,	16
 000001A4  8B 1D 00000084 R		mov			ebx,	[SubspanCounter]
 000001AA  3B D9			cmp			ebx,	ecx
 000001AC  0F 47 D9			cmova		ebx,	ecx

					; Prepare scaled deltas for multiplication
 000001AF  F3/ 0F 2A DB			cvtsi2ss	xmm3,	ebx
 000001B3  0F C6 DB 00			shufps		xmm3,	xmm3,	0
 000001B7  89 1D 000000C8 R		mov			[SubSpanWidth],	ebx

					; Compute offset into DivTable
 000001BD  C1 E3 04			shl			ebx,	4
 000001C0  0F 59 DA			mulps		xmm3,	xmm2

					; step ZUVX
 000001C3  0F 58 C3			addps		xmm0,	xmm3

					; xmm4 = z
					; edx = Z
 000001C6  F3/ 0F 53 E8			rcpss		xmm5,	xmm0
				;	movss		xmm5,	[f1]
				;	divss		xmm5,	xmm0

 000001CA  BA 0000FF80			mov			edx,	0ff80h
 000001CF  F3/ 0F 10 E5			movss		xmm4,	xmm5
 000001D3  F3/ 0F 59 2D			mulss		xmm5,	_g_zscale
	   00000000 E
 000001DB  F3/ 0F 2D CD			cvtss2si	ecx,	xmm5
 000001DF  2B D1			sub			edx,	ecx

					; xmm4 = UV affine (16bit fractional)
 000001E1  F3/ 0F 10 2D			movss		xmm5,	[pf65536]
	   00000190 R
 000001E9  F3/ 0F 59 E5			mulss		xmm4,	xmm5
 000001ED  0F C6 E4 00			shufps		xmm4,	xmm4,	00000000b
 000001F1  0F 59 E0			mulps		xmm4,	xmm0
 000001F4  0F C6 E4 09			shufps		xmm4,	xmm4,	00001001b

					; use rcpps?
 000001F8  0F 28 AB			movaps		xmm5,	[DivTable + ebx]
	   00000210 R
 000001FF  0F 28 F4			movaps		xmm6,	xmm4
 00000202  0F 5C F7			subps		xmm6,	xmm7
 00000205  0F 59 F5			mulps		xmm6,	xmm5

					; mm3 = [dUi:dUf] [dVi:dVf] (frees xmm4)
					; stores Z
					; edx = dzdx
 00000208  0F 2D DE			cvtps2pi	mm3,	xmm6
				;	movq		mm7,	mm3
 0000020B  89 15 00000080 R		mov			[SubspanZ], edx
				;	psubd		mm3,	mm2
 00000211  2B D0			sub			edx,	eax

					; Fix Rounding Errors
 00000213  BB 00000008			mov			ebx,	8
 00000218  B9 FFFFFFF8			mov			ecx,	-8
 0000021D  0F 48 D9			cmovs		ebx,	ecx
 00000220  03 D3			add			edx,	ebx
					
				;	psrad		mm3,	4
					; should divide by subspan width, not 16.
					; very so fucked up code
				;	sar			edx,	4

 00000222  8B 0D 000000C8 R		mov			ecx,	[SubSpanWidth]
 00000228  03 C9			add			ecx,	ecx
 0000022A  03 C9			add			ecx,	ecx
 0000022C  8B D8			mov			ebx,	eax

 0000022E  8B 81 0000034C R		mov			eax,	[RITable+ecx]
 00000234  F7 EA			imul		edx
 00000236  8B C3			mov			eax,	ebx

					; not so fucked up code
					; dudx = [Ui:Uf], dvdx = [Vi:Vf] (frees mm3)

					; dudx = wwww ww11 1111 11ww 1fff ffff ffff ffff
 00000238  0F 7E DB			movd		ebx,	mm3
 0000023B  0F 7E D9			movd		ecx,	mm3
					
 0000023E  81 E1 00FC0000		and			ecx,    000fc0000h  ; TB0(logWidth)
					org			$-4
 00000240 00FC0000			smc_TB0Wd1	dd		000fc0000h

 00000244  C1 E1 08			shl			ecx,	8			; logHeight
					org			$ - 1
 00000246 08				smc_Hb1		db		8

 00000247  81 E3 00030000		and			ebx,	000030000h

 0000024D  81 CB 03FC8000		or			ebx,	003fc8000h	;	TB1(logHeight)
					org			$-4
 0000024F 03FC8000			smc_TB1Hd1	dd		003fc8000h

 00000253  0B D9			or			ebx,	ecx

 00000255  0F 7E D9			movd		ecx,	mm3
 00000258  D1 E9			shr			ecx,	1

 0000025A  81 E1 00007FFF		and			ecx,	07fffh
 00000260  0B D9			or			ebx,	ecx
 00000262  89 1D 00000078 R		mov			[dudx],	ebx

					;		 0000 0000 wwww wwww ffff ffff ffff fff*
					; dvdx = 1111 11ww wwww ww11 1fff ffff ffff ffff
 00000268  0F 70 DB 4E			pshufw		mm3,	mm3,	01001110b
 0000026C  0F 7E D9			movd		ecx,	mm3
 0000026F  0F 7E DB			movd		ebx,	mm3
						
 00000272  D1 E9			shr			ecx,	1

 00000274  81 E3 00FF0000		and			ebx,	000ff0000h	;	T0(logHeight)
					org			$-4
 00000276 00FF0000			smc_T0Hd2	dd		000ff0000h

 0000027A  03 DB			add			ebx,	ebx
 0000027C  03 DB			add			ebx,	ebx

				;	TODO:try to eliminate use of another lookup table
				;	or			ecx,	0ffff8000h
				;	and			ecx,	ebx

 0000027E  81 E1 00007FFF		and			ecx,	07fffh

 00000284  81 CB FC038000		or			ebx,	0fc038000h	;	T2_22(logHeight)
					org			$-4
 00000286 FC038000			smc_TB2Hd3	dd		0fc038000h

 0000028A  0B D9			or			ebx,	ecx
 0000028C  89 1D 0000007C R		mov			[dvdx],	ebx

 00000292  0F 70 DB 4E			pshufw		mm3,	mm3,	01001110b

				;	; step ZUVX
				;	addps		xmm0,	xmm3

 00000296  8B 1D 000000C8 R		mov			ebx,	[SubSpanWidth]
				;	mov			ecx,	16
				;	mov			ebx,	[SubspanCounter]
				;	cmp			ebx,	ecx
				;	cmova		ebx,	ecx

 0000029C  8D 0C 1B			lea ecx,[ebx+ebx]
 0000029F  F7 D9			neg ecx

 000002A1  2B E1			sub esp, ecx
				;	sub [t_edi], ecx
 000002A3  2B F1			sub esi, ecx
 000002A5  2B E1			sub esp, ecx
				;	sub [t_edi], ecx

				; Register allocation table

				; Generic
				; esp - Page ptr

				; ZBuffer
				; eax - current Z (low word)
				; edx - dZ/dx (low word)
				; esi - ZBuffer ptr
				; ecx - offset counter (low byte)

				; Gouraud
				; mm0 - Color
				; mm1 - dColor/dx

				; Texture
				; mm2 - u, v
				; mm7 - next u, v
				; Required: u, v, du, dv (8:8 each); Texture ptr (dword)
				; add (u, v), (du, dv) will be made on an mmx register
				; texture ptr will be smeared on an entire mmx register and added to (u, v) on a seperate reg.
				; unloaded to a memory location and loaded into ebp then accessed directly using [ebp]
				; or maybe we need a different plan.. because addr isn't always = u+v*256

				; Free registers
				; CPU: none
				; MMX: mm3-6
				; SSE: xmm1,xmm5-6


				;align 16
 000002A7				Inner:
 000002A7  66| 3B 04 0E				cmp ax, word ptr [esi+ecx]
 000002AB  76 26				jbe nodraw ; remark to disable zbuffer

						; get texture
 000002AD  8D 1C 2F				lea		ebx,	[edi+ebp]
 000002B0  C1 EB 10				shr		ebx,	16

 000002B3  66| 89 04 0E				mov  word ptr [esi+ecx], ax

 000002B7  0F EF E4				pxor	mm4,	mm4
						
 000002BA  0F 6E 2C 9D				movd	mm5,	dword ptr [ebx*4 + 060000000h]
	   60000000
						org $ - 4
 000002BE 00000000				SMC_Texture dd 0

				;		movd		mm5,	[whitecolor]

 000002C2  0F 60 EC				punpcklbw	mm5,	mm4
 000002C5  0F E4 E8				pmulhuw		mm5,	mm0
 000002C8  0F 71 F5 01				psllw		mm5,	1
 000002CC  0F 67 ED				packuswb	mm5,	mm5
						
						; write to screen
 000002CF  0F 7E 2C 4C				movd dword ptr [esp+ecx*2], mm5

				;		xor [t_edi] , edi
				;		xor edi,  [t_edi]
				;		xor [t_edi] , edi

				;		xchg	edi, [t_edi]
				;		movd [edi+ecx*2], mm5
				;		xchg	edi, [t_edi]

				;		xor [t_edi] , edi
				;		xor edi,  [t_edi]
				;		xor [t_edi] , edi
 000002D3			nodraw:

				;		rol/ror needed to fix zbuffer last 3 precision bits... nobody cares
				;		rol eax,	4		

						; step gouraud
 000002D3  0F FD C1				paddw	mm0,	mm1

						; step texture
 000002D6  03 2D 00000078 R			add ebp,	[dudx]
 000002DC  03 3D 0000007C R			add edi,	[dvdx]

						; step current Z
 000002E2  03 C2				add eax, edx
				;		ror eax,	4

 000002E4  81 E5 FC037FFF			and ebp,	0fc037fffh   ; (TB2(logHeight)-1) & ((1<<(logWidth+logHeight+16))-1)
						org $ - 4
 000002E6 FC037FFF				smc_TB2Wd2	dd	0fc037fffh

 000002EA  81 E7 03FC7FFF			and	edi,	003fc7fffh	; TB1(logHeight)-1
						org $ - 4
 000002EC 03FC7FFF				smc_TB1Hd4	dd	003fc7fffh
						
						; step to next pixel
 000002F0  83 C1 02				add ecx, 2
 000002F3  75 B2				jnz Inner

				;	mov dword ptr [esp-4], 000ffffffh

					
 000002F5  0F 7F FA			movq	mm2,	mm7
 000002F8  0F 28 FC			movaps	xmm7,	xmm4
				;	pslld	mm3,	4
				;	paddd	mm2,	mm3
					
 000002FB  A1 00000080 R		mov eax, [SubspanZ]	
 00000300  8B 15 00000084 R		mov edx, [SubspanCounter]
 00000306  83 EA 10			sub edx, 16
 00000309  89 15 00000084 R		mov [SubspanCounter], edx
 0000030F  0F 8F FFFFFE8A		jg Outer
 00000315			Terminate:
					; restore esp, so procedure pointers won't fuck up and shit.
 00000315  8B 25 00000090 R		mov esp,[save_esp]
 0000031B  C3				ret
 0000031C			TGZM_SpanLoop		endp

				;;;;;;;;;;;;;;;;
 0000031C			_IX_TGZM_AsmFiller	proc	near


				;static void IXAsmFiller(IXVertex *Verts, dword numVerts, void *Texture, void *Page, dword logWidth, dword logHeight)

				;;; ARGUMENTS ;;;
 = esp + 4h				Arg_Verts		equ		esp + 4h
 = esp + 8h				Arg_NumVerts	equ		esp + 8h
 = esp + 0Ch				Arg_Texture		equ		esp + 0Ch
 = esp + 10h				Arg_Page		equ		esp + 10h
 = esp + 14h				Arg_LogWidth	equ		esp + 14h
 = esp + 18h				Arg_LogHeight	equ		esp + 18h
					
				;IX.Texture = Texture;
 0000031C  8B 44 24 0C			mov	eax,		[Arg_Texture]
 00000320  A3 000000E4 R		mov	[_Texture],	eax
					; SMC code
 00000325  A3 000002BE R		mov	ds:[SMC_Texture],	eax

				;IX.L2Size = logWidth; // Change this to "LogSize" when changing filler arguments
 0000032A  8B 44 24 14			mov	eax,		[Arg_LogWidth]
 0000032E  A3 000000D8 R		mov	[_L2Size], eax

				;IX.Page = Page;
 00000333  8B 44 24 10			mov eax,		[Arg_Page]
 00000337  A3 000000D4 R		mov	[_Page],	eax

				;// ZBuffer data starts at the end of framebuffer
				;IX.ZBuffer = (word *) ((dword)Page + PageSize);
 0000033C  03 05 00000000 E		add	eax,		[_PageSize]
 00000342  A3 000000DC R		mov [_ZBuffer],	eax

				;	SMC: Update masks based on texture dimensions
 00000347  8B 44 24 14			mov eax, [Arg_LogWidth]
 0000034B  8B 1D 000000C0 R		mov	ebx, [LastLogWidth]
 00000351  8B 4C 24 18			mov ecx, [Arg_LogHeight]
 00000355  8B 15 000000C4 R		mov edx, [LastLogHeight]
 0000035B  3B D8			cmp ebx, eax
 0000035D  75 08			jne SMC_update
 0000035F  3B D1			cmp edx, ecx
 00000361  0F 84 00000083		je after_SMC_update

 00000367			SMC_update:
 00000367  A3 000000C0 R		mov	[LastLogWidth],		eax
 0000036C  89 0D 000000C4 R		mov [LastLogHeight],	ecx

 00000372  8B 1C 85			mov	ebx,	[_TB0 + eax * 4 - 4]	; TB0[Arg_LogWidth]
	   0000012C R
 00000379  8B 14 8D			mov	edx,	[_TB0 + ecx * 4 - 4]	; TB0[Arg_LogHeight]
	   0000012C R

 00000380  89 1D 0000015E R		mov	ds:[smc_TB0Wd0],	ebx
 00000386  89 1D 00000240 R		mov ds:[smc_TB0Wd1],	ebx
 0000038C  88 0D 00000164 R		mov ds:[smc_Hb0],		cl
 00000392  88 0D 00000246 R		mov ds:[smc_Hb1],		cl


 00000398  8B 14 8D			mov	edx,	[_T0 + ecx * 4 - 4]	; T0[Arg_LogHeight]
	   000000EC R
 0000039F  89 15 0000018B R		mov ds:[smc_T0Hd0],	edx
 000003A5  89 15 00000276 R		mov ds:[smc_T0Hd2],	edx

 000003AB  8B 14 8D			mov	edx,	[_TB1 + ecx * 4 - 4]	; TB1[Arg_LogHeight]
	   0000014C R
 000003B2  89 15 0000024F R		mov ds:[smc_TB1Hd1],	edx
 000003B8  83 EA 01			sub	edx,	1
 000003BB  89 15 000002EC R		mov	ds:[smc_TB1Hd4],	edx

 000003C1  BF 00000001			mov edi,	1
 000003C6  8B 14 8D			mov	edx,	[_TB2 + ecx * 4 - 4]	; TB2[Arg_LogHeight]
	   0000016C R
 000003CD  02 C8			add cl,		al
 000003CF  80 C1 0F			add	cl,		15
 000003D2  D3 E7			shl edi,	cl
 000003D4  03 FF			add edi,	edi
 000003D6  89 15 00000286 R		mov ds:[smc_TB2Hd3],	edx
 000003DC  83 EA 01			sub	edx,	1
 000003DF  83 EF 01			sub	edi,	1
 000003E2  23 D7			and edx,	edi
 000003E4  89 15 000002E6 R		mov	ds:[smc_TB2Wd2],	edx


				comment &
					mov	ds:[smc_T0Hd0],	edx
					mov	ds:[smc_Wb0],	al
					mov	ds:[smc_T0Wd1],	ebx
					mov	ds:[smc_T0Hd1],	edx
					mov ds:[smc_T0Hd2],	edi
					mov ds:[smc_T0Wd3],	esi

					mov	ebx,	[_T1 + eax * 4 - 4]	; T1[Arg_LogWidth]
					mov	edx,	[_T1 + ecx * 4 - 4]	; T1[Arg_LogHeight]

					mov ds:[_Wb1],		al

				;	calculates mask width*(height-1) : 7fffh
					mov edi,	1
					shl	edi,	cl
					sub edi,	1

					mov cl,		al
					add cl,		16
					shl edi,	cl
					or	edi,	07fffh

					mov ds:[smc_T1Wd2],	ebx
					mov ds:[smc_T1Hd3],	edi
				&
					


 000003EA			after_SMC_update:

				;Left.Vert = Verts + 1;
				;Right.Vert = Verts + numVerts - 1;
					
				;; esi - Verts
 000003EA  8B 74 24 04			mov	esi,			[Arg_Verts]
 000003EE  B8 00000030			mov eax,			VertexSize
 000003F3  F7 64 24 08			mul dword ptr		[Arg_NumVerts]
 000003F7  8D 58 D0			lea ebx,			[eax - VertexSize]

				;; ebx - Verts + Arg_NumVerts - 1
 000003FA  03 DE			add ebx,			esi

				;; edi - Verts + 1
 000003FC  8D 7E 30			lea edi,			[esi + VertexSize]

				;CalcLeftSection (Verts, Verts + 1);

 000003FF  E8 FFFFFC8B			call	TGZM_CalcLeftSection

				;	while (IX.Left.ScanLines == 0)
				;	{
				;		CalcLeftSection(Verts + IX.Left.Index, Verts + IX.Left.Index + 1);
				;		IX.Left.Index++;
				;		if (IX.Left.Index > numVerts - 1)
				;		{
				;			return;
				;		}
				;	}

 00000404			CalcLeftLoop:

 00000404  83 F8 00			cmp eax, 0
 00000407  75 14			jnz short LeftCalculated

 00000409  3B FB				cmp edi, ebx
 0000040B  0F 83 000002AF			jae JmpRet

 00000411  8B F7				mov esi,	edi
 00000413  83 C7 30				add edi,	VertexSize
 00000416  E8 FFFFFC74				call TGZM_CalcLeftSection


 0000041B  EB E7			jmp CalcLeftLoop


 0000041D			LeftCalculated:

 0000041D  89 3D 000000A0 R		mov [Left_Vert], edi

				;CalcRightSection (Verts, Verts + IX.Right.Index]);

 00000423  8B 74 24 04			mov esi,	[Arg_Verts]
 00000427  8B FB			mov edi,	ebx
 00000429  E8 FFFFFBD2			call TGZM_CalcRightSection


				;	while (IX.Right.ScanLines == 0)
				;	{
				;		CalcRightSection (Verts + IX.Right.Index, Verts + IX.Right.Index - 1);
				;		IX.Right.Index--;
				;	}

 0000042E			CalcRightLoop:

 0000042E  83 F8 00			cmp eax, 0
 00000431  75 0C			jnz short RightCalculated

 00000433  8B F7				mov esi, edi
 00000435  83 EF 30				sub edi, VertexSize
 00000438  E8 FFFFFBC3				call TGZM_CalcRightSection

 0000043D  EB EF			jmp CalcRightLoop

 0000043F			RightCalculated:

 0000043F  89 3D 000000B0 R		mov [Right_Vert], edi


				; Calculate constant deltas

				;	float dy01 = Verts[1].Y - Verts[0].Y;
				;	float dy02 = Verts[2].Y - Verts[0].Y;
				;	float invArea = 1.0 / ((Verts[1].X - Verts[0].X) * dy02 - (Verts[2].X - Verts[0].X) * dy01);
				;	ddx.dUZdx = invArea * ((Verts[1].UZ - Verts[0].UZ) * dy02 - (Verts[2].UZ - Verts[0].UZ) * dy01);
				;	ddx.dVZdx = invArea * ((Verts[1].VZ - Verts[0].VZ) * dy02 - (Verts[2].VZ - Verts[0].VZ) * dy01);
				;	ddx.dRZdx = invArea * ((Verts[1].RZ - Verts[0].RZ) * dy02 - (Verts[2].RZ - Verts[0].RZ) * dy01);

					; make sure that ebx points to first vertex
 00000445  8B 5C 24 04			mov			ebx,		[Arg_Verts]
					; xmm0 = Verts[0].Y
 00000449  F3/ 0F 10 43			movss	xmm0,	dword ptr [ebx + Vertex_Y]
	   20
					; xmm1 = Verts[1].Y
 0000044E  F3/ 0F 10 4B			movss	xmm1,	dword ptr [ebx + VertexSize + Vertex_Y]
	   50
					; xmm2 = Verts[2].Y
 00000453  F3/ 0F 10 93			movss	xmm2,	dword ptr [ebx + VertexSize * 2 + Vertex_Y]
	   00000080

					; xmm3 = V[1] - V[0]	xmm4 = V[2] - V[0]	xmm5 = V[0]
 0000045B  0F 28 2B			movaps	xmm5,	dword ptr [ebx + Vertex_RZ]
					; xmm1 = dy01
 0000045E  F3/ 0F 5C C8			subss	xmm1,	xmm0
 00000462  0F 28 5B 30			movaps	xmm3,	dword ptr [ebx + VertexSize + Vertex_RZ]
 00000466  0F C6 C9 00			shufps	xmm1,	xmm1,	00000000b
					; xmm2 = dy02
 0000046A  F3/ 0F 5C D0			subss	xmm2,	xmm0
 0000046E  0F 28 63 60			movaps	xmm4,	dword ptr [ebx + VertexSize * 2 + Vertex_RZ]
 00000472  0F C6 D2 00			shufps	xmm2,	xmm2,	00000000b
 00000476  0F 5C DD			subps	xmm3,	xmm5
 00000479  0F 5C E5			subps	xmm4,	xmm5

					; xmm3 = (V[1] - V[0]) * dy02
 0000047C  0F 59 DA			mulps	xmm3,	xmm2
					; xmm4 = (V[2] - V[0]) * dy01
 0000047F  0F 59 E1			mulps	xmm4,	xmm1

					; xmm3 = (V[1] - V[0]) * dy02 - (V[2] - V[0]) * dy01 (xmm3 - xmm4)
 00000482  0F 5C DC			subps	xmm3,	xmm4
					
					; store Area in xmm0
 00000485  0F 28 FB			movaps	xmm7,	xmm3
 00000488  0F C6 FF FF			shufps	xmm7,   xmm7, 11111111b
					; xmm1[0] = invArea
					; could use rcpps
 0000048C  F3/ 0F 53 C7			rcpss	xmm0,	xmm7
				;	movss	xmm0,   [f1]
				;	divss	xmm0,	xmm7

					; fill xmm0 with invArea
 00000490  0F C6 C0 00			shufps	xmm0,   xmm0, 00000000b
					; xmm1 = Constant texture deltas
 00000494  0F 59 C3			mulps	xmm0,	xmm3
					; store constant deltas
 00000497  0F 29 05			movaps	[_dRZdx],	xmm0
	   00000060 R
					; multiply constant deltas by span size
				;	mulps	xmm0,	[_pfSPANSIZE]
					; store constant deltas * Span Size
				;	movaps	[_sdRZdx],	xmm0

				;	y = Fist(Verts[0].Y);
				;	Page = (dword *)((dword)Page + VESA_BPSL * y);
				;	word *ZBuffer = (word *)((dword)Page + PageSize + sizeof(word) * XRes * y);

					; edi = _Page
 0000049E  F3/ 0F 10 43			movss		xmm0,		dword ptr [ebx + Vertex_Y]
	   20
 000004A3  F3/ 0F 2D C0			cvtss2si	eax,		xmm0
 000004A7  8B 0D 00000000 E		mov			ecx,		[_VESA_BPSL]
 000004AD  8B 3D 000000D4 R		mov			edi,		[_Page]
 000004B3  8B F0			mov			esi,		eax
					; Calculate Screen Pointer
 000004B5  F7 E1			mul			ecx
 000004B7  03 F8			add			edi,		eax
 000004B9  89 3D 000000D4 R		mov			[_Page],	edi
 000004BF  8B C6			mov			eax,		esi
 000004C1  8B 0D 00000000 E		mov			ecx,		[_XRes]
					; Calculate ZBuffer Pointer
 000004C7  F7 E1			mul			ecx
 000004C9  8B 15 000000DC R		mov			edx,		[_ZBuffer]
					; eax = XRes * y * 2
 000004CF  03 C0			add			eax,		eax
 000004D1  03 D0			add			edx,		eax
 000004D3  89 15 000000DC R		mov			[_ZBuffer],	edx

				;	SectionHeight = (Left.ScanLines < Right.ScanLines) ? Left.ScanLines : Right.ScanLines;
 000004D9  8B 1D 0000009C R		mov			ebx,	[Left_ScanLines]
 000004DF  A1 000000AC R		mov			eax,	[Right_ScanLines]
 000004E4  3B C3			cmp			eax,	ebx
 000004E6  0F 42 D8			cmovb		ebx,	eax

 000004E9  89 1D 000000B8 R		mov			[_SectionHeight], ebx
 000004EF  89 1D 000000BC R		mov			[_HeightCounter], ebx

				;	// Iterate over sections
 000004F5			SectionLoop:
					
				;	// Iterate over scanlines
 000004F5			ScanLineLoop:

							;lx = Fist(Left.X);
							;dword *LinePagePtr = Page + lx;
							;word *LineZPtr = ZBuffer + lx;
 000004F5  F3/ 0F 10 05					movss		xmm0,	[Left_X]
	   0000000C R
							; eax = lx, xmm0 = Left_X
 000004FD  F3/ 0F 2D C0					cvtss2si	eax,	xmm0
							; esi = LineZPtr
 00000501  8B 35 000000DC R				mov			esi,	[_ZBuffer]
 00000507  8D 1C 00					lea			ebx,	[eax + eax]
 0000050A  03 F3					add			esi,	ebx
							; edi = LineScrPtr
 0000050C  8B 3D 000000D4 R				mov			edi,	[_Page]
 00000512  03 DB					add			ebx,	ebx
 00000514  03 FB					add			edi,	ebx

				;			// Calculate scan-line width	
				;			rx = Fist(Right.X);
				;			Width = rx - lx;
 00000516  F3/ 0F 10 0D					movss		xmm1,	[Right_X]
	   00000088 R
 0000051E  F3/ 0F 2D D9					cvtss2si	ebx,	xmm1
							; ebx = Width, xmm1 = Right_X
 00000522  2B D8					sub			ebx,	eax	
				;			if (Width <= 0)
				;				goto AfterScanConv;
 00000524  7E 7C					jle AfterScanConv

				;			Texture delta calculation
				;			xmm7 used as temporary.

							; forward loading 
 00000526  0F 28 15					movaps		xmm2, [_dRZdx]
	   00000060 R
				;			movaps		xmm3, [_sdRZdx]
 0000052D  0F 28 35					movaps		xmm6, [Left_RZ]
	   00000000 R

							; xmm1 = Scan Line Width
 00000534  F3/ 0F 5C C8					subss		xmm1,	xmm0

							; xmm0 = span prestep
 00000538  F3/ 0F 2A F8					cvtsi2ss	xmm7, eax
 0000053C  F3/ 0F 5C F8					subss		xmm7, xmm0
 00000540  0F C6 FF 00					shufps	xmm7,	xmm7,	00000000b

							; xmm7 = prestep * deltas
							; xmm2 = constant d/dx
							; xmm3 = scaled d/dX
							; xmm0 = left before prestep
				;			movaps		xmm2, [pf0]
				;			movaps		xmm3, [pf0]
 00000544  0F 28 C6					movaps		xmm0, xmm6
 00000547  0F 59 FA					mulps		xmm7, xmm2
							
							
							; xmm0 = initial left
 0000054A  0F 58 C7					addps		xmm0, xmm7


				;			Gouraud delta calculation
				;			xmm6,xmm7 used as temporary

				;			sdword rWidth;
				;			if (Width>1)
				;			{
				;				rWidth = Fist(65536.0 / (Right.X - Left.X));
				;				sdword delta;
				;				delta = (sdword)Right.R - (sdword)Left.R >> 8;
				;				dRdx = delta * rWidth >> 16;
				;				delta = (sdword)Right.G - (sdword)Left.G >> 8;
				;				dGdx = delta * rWidth >> 16;
				;				delta = (sdword)Right.B - (sdword)Left.B >> 8;
				;				dBdx = delta * rWidth >> 16;
				;				delta = (sdword)Right.Z - (sdword)Left.Z >> 8;
				;				dZdx = delta * rWidth >> 16;
				;			} else {
				;				dRdx = dGdx = dBdx = 0;
				;			}


 0000054D  0F 28 35					movaps		xmm6,	[Left_R]
	   00000020 R
 00000554  83 FB 01					cmp	ebx,1
 00000557  74 2A					je	ZeroDeltas
				;			this section places RGBA 8:8 deltas into mm0
							; xmm1 = 1.0 / Scan Line Width
 00000559  F3/ 0F 53 C9					rcpss		xmm1,	xmm1		
 0000055D  0F 28 3D					movaps		xmm7,	[Right_R]
	   00000040 R
 00000564  0F C6 C9 00					shufps		xmm1,	xmm1,	0000000b
							; xmm4 = Right_RGBA - Left_RGBA
 00000568  0F 5C FE					subps		xmm7,	xmm6
							; xmm4 = RGBA deltas
 0000056B  0F 59 F9					mulps		xmm7,	xmm1			

							; Convert deltas to 8.8 fixed point in mm1
 0000056E  0F 59 3D					mulps		xmm7,	[pf256]
	   000001B0 R
 00000575  0F 2D CF					cvtps2pi	mm1,	xmm7
 00000578  0F 12 FF					movhlps		xmm7,	xmm7
 0000057B  0F 2D C7					cvtps2pi	mm0,	xmm7
 0000057E  0F 6B C8					packssdw	mm1,	mm0
				;			psllw		mm1,	1

 00000581  EB 03					jmp			CallSpanLoop
 00000583			ZeroDeltas:
 00000583  0F EF C0					pxor		mm0,	mm0			

 00000586			CallSpanLoop:

				;   prepare left RGB (mm1)
 00000586  0F 59 35					mulps		xmm6,	[pf128]
	   000001C0 R
 0000058D  0F 2D C6					cvtps2pi	mm0,	xmm6
 00000590  0F 12 F6					movhlps		xmm6,	xmm6
 00000593  0F 2D D6					cvtps2pi	mm2,	xmm6
 00000596  0F 6B C2					packssdw	mm0,	mm2
 00000599  0F 71 F0 01					psllw		mm0,	1

				;	Summery: Span loop Input
				;	mm1, mm0:	RGB, delta
				;	ebx:		span width
				;	edi:		span ptr
				;	esi:		Zbuffer ptr
				;	xmm0:		ZUVX initial left
				;	xmm2:		ZUVX constant d/dx
				;	xmm3:		ZUVX scaled d/dx

				;			push edi
 0000059D  E8 FFFFFB71					Call		TGZM_SpanLoop
				;			pop edi
				;			mov dword ptr [edi], 0FFFFFFFFh

 000005A2			AfterScanConv:
				;			forward loading : left Edge values
 000005A2  0F 28 05					movaps		xmm0,		[Left_RZ]
	   00000000 R
 000005A9  0F 28 25					movaps		xmm4,		[Left_dRZ]
	   00000010 R
 000005B0  0F 28 0D					movaps		xmm1,		[Left_R]
	   00000020 R
 000005B7  0F 28 2D					movaps		xmm5,		[Left_dR]
	   00000030 R

				;			_Page(eax) += VESA_BPSL(ecx);
				;			_ZBuffer(ebx) += XRes(edx);
 000005BE  8B 15 00000000 E				mov			edx,	[_XRes]
 000005C4  A1 000000D4 R				mov			eax,	[_Page]
 000005C9  8B 1D 000000DC R				mov			ebx,	[_ZBuffer]
 000005CF  8B 0D 00000000 E				mov			ecx,	[_VESA_BPSL]
 000005D5  03 D2					add			edx,	edx
 000005D7  03 C1					add			eax,	ecx
 000005D9  03 DA					add			ebx,	edx
 000005DB  A3 000000D4 R				mov			[_Page],	eax
 000005E0  89 1D 000000DC R				mov			[_ZBuffer],	ebx

				;			forward loading : right Edge values
 000005E6  0F 28 15					movaps		xmm2,		[Right_R]
	   00000040 R
 000005ED  0F 28 35					movaps		xmm6,		[Right_dR]
	   00000050 R
 000005F4  F3/ 0F 10 1D					movss		xmm3,		[Right_X]
	   00000088 R
 000005FC  F3/ 0F 10 3D					movss		xmm7,		[Right_dX]
	   0000008C R

				;			Update Edge Values
 00000604  0F 58 C4					addps		xmm0,		xmm4
 00000607  0F 58 CD					addps		xmm1,		xmm5

 0000060A  0F 58 D6					addps		xmm2,		xmm6
 0000060D  F3/ 0F 58 DF					addss		xmm3,		xmm7

 00000611  0F 29 05					movaps		[Left_RZ],	xmm0
	   00000000 R
 00000618  0F 29 0D					movaps		[Left_R],	xmm1
	   00000020 R
 0000061F  0F 29 15					movaps		[Right_R],	xmm2
	   00000040 R
 00000626  F3/ 0F 11 1D					movss		[Right_X],	xmm3
	   00000088 R

							; Decrease section height and jump to next iterate if needed
 0000062E  8B 0D 000000BC R				mov			ecx,	[_HeightCounter]
 00000634  83 E9 01					sub			ecx,	1
 00000637  89 0D 000000BC R				mov			[_HeightCounter], ecx
 0000063D  0F 85 FFFFFEB2				jnz		ScanLineLoop


				; IX.Left.ScanLines -= SectionHeight;

				; while (IX.Left.ScanLines == 0)
				; {
				;	if (IX.Left.Index == IX.Right.Index)
				;	{
				;		return; // End mapper!
				;	}	
				;	CalcLeftSection (&Verts[IX.Left.Index], &Verts[IX.Left.Index + 1]);
				;	IX.Left.Index ++;
				; }

				;; edx = SectionHeight
 00000643  8B 15 000000B8 R			mov edx,	 [_SectionHeight]		
 00000649  A1 0000009C R			mov eax,	 [Left_ScanLines]
 0000064E  2B C2				sub eax,	 edx
 00000650  A3 0000009C R			mov [Left_ScanLines],	 eax

				;; esi = Left_Vert		
 00000655  8B 3D 000000A0 R			mov edi,	[Left_Vert]
				;; ebx = Right_Vert
 0000065B  8B 1D 000000B0 R			mov ebx,	[Right_Vert]

 00000661  75 18				jnz ReCalcRight
 00000663			LeftAgain:
 00000663  3B FB				cmp	edi,	ebx
 00000665  74 59				jz	JmpRet

 00000667  8B F7				mov esi,	 edi
 00000669  83 C7 30				add edi,	 VertexSize
 0000066C  E8 FFFFFA1E				call TGZM_CalcLeftSection

 00000671  85 C0				test eax, eax
 00000673  74 EE				jz LeftAgain

 00000675  89 3D 000000A0 R			mov [Left_Vert],	edi

 0000067B			ReCalcRight:

				;		Right.ScanLines -= SectionHeight;
				;		while (Right.ScanLines == 0)
				;		{
				;			CalcRightSection (&Verts[Right.Index], &Verts[Right.Index - 1]);
				;			Right.Index --;
				;		}

 0000067B  A1 000000AC R			mov eax,	[Right_ScanLines]
 00000680  2B C2				sub eax,	edx;		
 00000682  A3 000000AC R			mov [Right_ScanLines],	 eax

 00000687  75 16				jnz CalcSectionHeight
 00000689  8B FB				mov edi, ebx
 0000068B			RightAgain:
 0000068B  8B F7				mov esi,	edi
 0000068D  83 EF 30				sub edi,	VertexSize
 00000690  E8 FFFFF96B				call TGZM_CalcRightSection

						
 00000695  85 C0				test eax, eax
 00000697  74 F2				jz RightAgain

 00000699  89 3D 000000B0 R			mov [Right_Vert], edi

 0000069F			CalcSectionHeight:

				;	SectionHeight = (Left.ScanLines < Right.ScanLines) ? Left.ScanLines : Right.ScanLines;
 0000069F  8B 1D 0000009C R		mov			ebx,	[Left_ScanLines]
 000006A5  A1 000000AC R		mov			eax,	[Right_ScanLines]
 000006AA  3B C3			cmp			eax,	ebx
 000006AC  0F 42 D8			cmovb		ebx,	eax

 000006AF  89 1D 000000B8 R		mov			[_SectionHeight], ebx
 000006B5  89 1D 000000BC R		mov			[_HeightCounter], ebx
					
 000006BB  E9 FFFFFE35			jmp SectionLoop

 000006C0			JmpRet:
 000006C0  0F 77			emms
 000006C2  C3				ret
 000006C3			_IX_TGZM_AsmFiller				endp
				;;;;;;;;;;;;;;;;

 000006C3 = 000006C3		ASM_FILE_END	equ	$

 06C3				_TEXT   ENDS

				END
Microsoft (R) Macro Assembler Version 14.15.26730.0	    10/31/18 01:22:14
C:\Projects\REVIVAL\FDS\FILLERS\IXTGZM.ASM		     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

_DATA  . . . . . . . . . . . . .	32 Bit	 039C	  Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 06C3	  Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

TGZM_CalcLeftSection . . . . . .	P Near	 008F	  _TEXT	Length= 0084 Public
  JmpRet . . . . . . . . . . . .	L Near	 0111	  _TEXT	
TGZM_CalcRightSection  . . . . .	P Near	 0000	  _TEXT	Length= 008F Public
  JmpRet . . . . . . . . . . . .	L Near	 008D	  _TEXT	
TGZM_SpanLoop  . . . . . . . . .	P Near	 0113	  _TEXT	Length= 0209 Public
  Outer  . . . . . . . . . . . .	L Near	 019F	  _TEXT	
  Inner  . . . . . . . . . . . .	L Near	 02A7	  _TEXT	
  nodraw . . . . . . . . . . . .	L Near	 02D3	  _TEXT	
  Terminate  . . . . . . . . . .	L Near	 0315	  _TEXT	
_IX_TGZM_AsmFiller . . . . . . .	P Near	 031C	  _TEXT	Length= 03A7 Public
  SMC_update . . . . . . . . . .	L Near	 0367	  _TEXT	
  after_SMC_update . . . . . . .	L Near	 03EA	  _TEXT	
  CalcLeftLoop . . . . . . . . .	L Near	 0404	  _TEXT	
  LeftCalculated . . . . . . . .	L Near	 041D	  _TEXT	
  CalcRightLoop  . . . . . . . .	L Near	 042E	  _TEXT	
  RightCalculated  . . . . . . .	L Near	 043F	  _TEXT	
  SectionLoop  . . . . . . . . .	L Near	 04F5	  _TEXT	
  ScanLineLoop . . . . . . . . .	L Near	 04F5	  _TEXT	
  ZeroDeltas . . . . . . . . . .	L Near	 0583	  _TEXT	
  CallSpanLoop . . . . . . . . .	L Near	 0586	  _TEXT	
  AfterScanConv  . . . . . . . .	L Near	 05A2	  _TEXT	
  LeftAgain  . . . . . . . . . .	L Near	 0663	  _TEXT	
  ReCalcRight  . . . . . . . . .	L Near	 067B	  _TEXT	
  RightAgain . . . . . . . . . .	L Near	 068B	  _TEXT	
  CalcSectionHeight  . . . . . .	L Near	 069F	  _TEXT	
  JmpRet . . . . . . . . . . . .	L Near	 06C0	  _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

ASM_FILE_END . . . . . . . . . .	Number	 06C3h	 
ASM_FILE_START . . . . . . . . .	Number	 0000h	 
Arg_LogHeight  . . . . . . . . .	Text   	 esp + 18h
Arg_LogWidth . . . . . . . . . .	Text   	 esp + 14h
Arg_NumVerts . . . . . . . . . .	Text   	 esp + 8h
Arg_Page . . . . . . . . . . . .	Text   	 esp + 10h
Arg_Texture  . . . . . . . . . .	Text   	 esp + 0Ch
Arg_Verts  . . . . . . . . . . .	Text   	 esp + 4h
DivTable . . . . . . . . . . . .	L Near	 0210	  _DATA	
LastLogHeight  . . . . . . . . .	DWord	 00C4	  _DATA	
LastLogWidth . . . . . . . . . .	DWord	 00C0	  _DATA	
Left_A . . . . . . . . . . . . .	DWord	 002C	  _DATA	
Left_B . . . . . . . . . . . . .	DWord	 0028	  _DATA	
Left_G . . . . . . . . . . . . .	DWord	 0024	  _DATA	
Left_Height  . . . . . . . . . .	DWord	 0098	  _DATA	
Left_RZ  . . . . . . . . . . . .	DWord	 0000	  _DATA	
Left_R . . . . . . . . . . . . .	DWord	 0020	  _DATA	
Left_ScanLines . . . . . . . . .	DWord	 009C	  _DATA	
Left_UZ  . . . . . . . . . . . .	DWord	 0004	  _DATA	
Left_VZ  . . . . . . . . . . . .	DWord	 0008	  _DATA	
Left_Vert  . . . . . . . . . . .	DWord	 00A0	  _DATA	
Left_X . . . . . . . . . . . . .	DWord	 000C	  _DATA	
Left_dA  . . . . . . . . . . . .	DWord	 003C	  _DATA	
Left_dB  . . . . . . . . . . . .	DWord	 0038	  _DATA	
Left_dG  . . . . . . . . . . . .	DWord	 0034	  _DATA	
Left_dRZ . . . . . . . . . . . .	DWord	 0010	  _DATA	
Left_dR  . . . . . . . . . . . .	DWord	 0030	  _DATA	
Left_dUZ . . . . . . . . . . . .	DWord	 0014	  _DATA	
Left_dVZ . . . . . . . . . . . .	DWord	 0018	  _DATA	
Left_dX  . . . . . . . . . . . .	DWord	 001C	  _DATA	
RITable  . . . . . . . . . . . .	Text   	 ri1 - 4
Right_A  . . . . . . . . . . . .	DWord	 004C	  _DATA	
Right_B  . . . . . . . . . . . .	DWord	 0048	  _DATA	
Right_G  . . . . . . . . . . . .	DWord	 0044	  _DATA	
Right_Height . . . . . . . . . .	DWord	 00A4	  _DATA	
Right_R  . . . . . . . . . . . .	DWord	 0040	  _DATA	
Right_ScanLines  . . . . . . . .	DWord	 00AC	  _DATA	
Right_Size . . . . . . . . . . .	DWord	 00B4	  _DATA	
Right_Vert . . . . . . . . . . .	DWord	 00B0	  _DATA	
Right_X  . . . . . . . . . . . .	DWord	 0088	  _DATA	
Right_dA . . . . . . . . . . . .	DWord	 005C	  _DATA	
Right_dB . . . . . . . . . . . .	DWord	 0058	  _DATA	
Right_dG . . . . . . . . . . . .	DWord	 0054	  _DATA	
Right_dR . . . . . . . . . . . .	DWord	 0050	  _DATA	
Right_dX . . . . . . . . . . . .	DWord	 008C	  _DATA	
Right_rHeight  . . . . . . . . .	DWord	 00A8	  _DATA	
SMC_Texture  . . . . . . . . . .	DWord	 02BE	  _TEXT	
SubSpanWidth . . . . . . . . . .	DWord	 00C8	  _DATA	
SubspanCounter . . . . . . . . .	DWord	 0084	  _DATA	
SubspanZ . . . . . . . . . . . .	DWord	 0080	  _DATA	
V1 . . . . . . . . . . . . . . .	Text   	 esi
V2 . . . . . . . . . . . . . . .	Text   	 edi
VertexSize . . . . . . . . . . .	Number	 0030h	 
Vertex_A . . . . . . . . . . . .	Number	 001Ch	 
Vertex_B . . . . . . . . . . . .	Number	 0018h	 
Vertex_G . . . . . . . . . . . .	Number	 0014h	 
Vertex_RZ  . . . . . . . . . . .	Number	 0000h	 
Vertex_R . . . . . . . . . . . .	Number	 0010h	 
Vertex_UZ  . . . . . . . . . . .	Number	 0004h	 
Vertex_VZ  . . . . . . . . . . .	Number	 0008h	 
Vertex_X . . . . . . . . . . . .	Number	 000Ch	 
Vertex_Y . . . . . . . . . . . .	Number	 0020h	 
_HeightCounter . . . . . . . . .	DWord	 00BC	  _DATA	
_IX_TGZM_Code_Size . . . . . . .	DWord	 0398	  _DATA	Public
_IX_TGZM_Code_Start  . . . . . .	DWord	 0394	  _DATA	Public
_L2SPANSIZE  . . . . . . . . . .	Number	 0004h	 
_L2Size  . . . . . . . . . . . .	DWord	 00D8	  _DATA	
_PageSize  . . . . . . . . . . .	DWord	 0000	  _DATA	External
_Page  . . . . . . . . . . . . .	DWord	 00D4	  _DATA	
_SPANSIZE  . . . . . . . . . . .	Number	 0010h	 
_SectionHeight . . . . . . . . .	DWord	 00B8	  _DATA	
_T0  . . . . . . . . . . . . . .	DWord	 00F0	  _DATA	
_T1  . . . . . . . . . . . . . .	DWord	 0110	  _DATA	
_TB0 . . . . . . . . . . . . . .	DWord	 0130	  _DATA	
_TB1 . . . . . . . . . . . . . .	DWord	 0150	  _DATA	
_TB2 . . . . . . . . . . . . . .	DWord	 0170	  _DATA	
_Texture . . . . . . . . . . . .	DWord	 00E4	  _DATA	
_VESA_BPSL . . . . . . . . . . .	DWord	 0000	  _DATA	External
_Verts . . . . . . . . . . . . .	DWord	 00E0	  _DATA	
_XRes  . . . . . . . . . . . . .	DWord	 0000	  _DATA	External
_ZBuffer . . . . . . . . . . . .	DWord	 00DC	  _DATA	
_dAdx  . . . . . . . . . . . . .	Word	 0076	  _DATA	
_dBdx  . . . . . . . . . . . . .	Word	 0074	  _DATA	
_dGdx  . . . . . . . . . . . . .	Word	 0072	  _DATA	
_dRZdx . . . . . . . . . . . . .	DWord	 0060	  _DATA	
_dRdx  . . . . . . . . . . . . .	Word	 0070	  _DATA	
_dUZdx . . . . . . . . . . . . .	DWord	 0064	  _DATA	
_dVZdx . . . . . . . . . . . . .	DWord	 0068	  _DATA	
_fSPANSIZE . . . . . . . . . . .	Text   	 f16
_filler1 . . . . . . . . . . . .	DWord	 006C	  _DATA	
_g_zscale256 . . . . . . . . . .	DWord	 0000	  _DATA	External
_g_zscale  . . . . . . . . . . .	DWord	 0000	  _DATA	External
_pfSPANSIZE  . . . . . . . . . .	Text   	 pf16
_tebp  . . . . . . . . . . . . .	DWord	 00CC	  _DATA	
align32  . . . . . . . . . . . .	DWord	 0094	  _DATA	
dudx . . . . . . . . . . . . . .	DWord	 0078	  _DATA	
dvdx . . . . . . . . . . . . . .	DWord	 007C	  _DATA	
f16  . . . . . . . . . . . . . .	Text   	 pf16
f1 . . . . . . . . . . . . . . .	DWord	 0200	  _DATA	
f256 . . . . . . . . . . . . . .	Text   	 pf256
f65536 . . . . . . . . . . . . .	Text   	 pf65536
pf0  . . . . . . . . . . . . . .	DWord	 01F0	  _DATA	
pf128  . . . . . . . . . . . . .	DWord	 01C0	  _DATA	
pf16 . . . . . . . . . . . . . .	DWord	 01D0	  _DATA	
pf256  . . . . . . . . . . . . .	DWord	 01B0	  _DATA	
pf32768  . . . . . . . . . . . .	DWord	 01A0	  _DATA	
pf65536  . . . . . . . . . . . .	DWord	 0190	  _DATA	
prf16  . . . . . . . . . . . . .	DWord	 01E0	  _DATA	
rf0  . . . . . . . . . . . . . .	DWord	 0210	  _DATA	
rf10 . . . . . . . . . . . . . .	DWord	 02B0	  _DATA	
rf11 . . . . . . . . . . . . . .	DWord	 02C0	  _DATA	
rf12 . . . . . . . . . . . . . .	DWord	 02D0	  _DATA	
rf13 . . . . . . . . . . . . . .	DWord	 02E0	  _DATA	
rf14 . . . . . . . . . . . . . .	DWord	 02F0	  _DATA	
rf15 . . . . . . . . . . . . . .	DWord	 0300	  _DATA	
rf16 . . . . . . . . . . . . . .	DWord	 0310	  _DATA	
rf17 . . . . . . . . . . . . . .	DWord	 0320	  _DATA	
rf18 . . . . . . . . . . . . . .	DWord	 0330	  _DATA	
rf19 . . . . . . . . . . . . . .	DWord	 0340	  _DATA	
rf1  . . . . . . . . . . . . . .	DWord	 0220	  _DATA	
rf2  . . . . . . . . . . . . . .	DWord	 0230	  _DATA	
rf3  . . . . . . . . . . . . . .	DWord	 0240	  _DATA	
rf4  . . . . . . . . . . . . . .	DWord	 0250	  _DATA	
rf5  . . . . . . . . . . . . . .	DWord	 0260	  _DATA	
rf6  . . . . . . . . . . . . . .	DWord	 0270	  _DATA	
rf7  . . . . . . . . . . . . . .	DWord	 0280	  _DATA	
rf8  . . . . . . . . . . . . . .	DWord	 0290	  _DATA	
rf9  . . . . . . . . . . . . . .	DWord	 02A0	  _DATA	
ri10 . . . . . . . . . . . . . .	DWord	 0374	  _DATA	
ri11 . . . . . . . . . . . . . .	DWord	 0378	  _DATA	
ri12 . . . . . . . . . . . . . .	DWord	 037C	  _DATA	
ri13 . . . . . . . . . . . . . .	DWord	 0380	  _DATA	
ri14 . . . . . . . . . . . . . .	DWord	 0384	  _DATA	
ri15 . . . . . . . . . . . . . .	DWord	 0388	  _DATA	
ri16 . . . . . . . . . . . . . .	DWord	 038C	  _DATA	
ri1  . . . . . . . . . . . . . .	DWord	 0350	  _DATA	
ri2  . . . . . . . . . . . . . .	DWord	 0354	  _DATA	
ri3  . . . . . . . . . . . . . .	DWord	 0358	  _DATA	
ri4  . . . . . . . . . . . . . .	DWord	 035C	  _DATA	
ri5  . . . . . . . . . . . . . .	DWord	 0360	  _DATA	
ri6  . . . . . . . . . . . . . .	DWord	 0364	  _DATA	
ri7  . . . . . . . . . . . . . .	DWord	 0368	  _DATA	
ri8  . . . . . . . . . . . . . .	DWord	 036C	  _DATA	
ri9  . . . . . . . . . . . . . .	DWord	 0370	  _DATA	
save_esp . . . . . . . . . . . .	DWord	 0090	  _DATA	
smc_Hb0  . . . . . . . . . . . .	Byte	 0164	  _TEXT	
smc_Hb1  . . . . . . . . . . . .	Byte	 0246	  _TEXT	
smc_T0Hd0  . . . . . . . . . . .	DWord	 018B	  _TEXT	
smc_T0Hd2  . . . . . . . . . . .	DWord	 0276	  _TEXT	
smc_TB0Wd0 . . . . . . . . . . .	DWord	 015E	  _TEXT	
smc_TB0Wd1 . . . . . . . . . . .	DWord	 0240	  _TEXT	
smc_TB1Hd1 . . . . . . . . . . .	DWord	 024F	  _TEXT	
smc_TB1Hd4 . . . . . . . . . . .	DWord	 02EC	  _TEXT	
smc_TB2Hd3 . . . . . . . . . . .	DWord	 0286	  _TEXT	
smc_TB2Wd2 . . . . . . . . . . .	DWord	 02E6	  _TEXT	
t_edi  . . . . . . . . . . . . .	DWord	 00D0	  _DATA	
whitecolor . . . . . . . . . . .	DWord	 0390	  _DATA	

	   0 Warnings
	   0 Errors
