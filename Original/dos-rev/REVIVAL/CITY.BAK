
#include "Rev.H"

#include "City.H"

static Scene *CitySc;
static Object *RflObj;
static Vector RflSurfNorm;
static float RflSurfOfs;

static long CTPartTime = 40.00 * 100;


signed char *STbl,*SOTbl,*CTbl,*COTbl;

void Calc_STable()
{
	STbl = new signed char [15*XRes];
	SOTbl = STbl + 5*XRes;
	long I;
	for(I=-5*XRes;I<10*XRes;I++)
		SOTbl[I] = (long) (1.5f * sin (I * 0.01f));
}

void Calc_CTable()
{
	CTbl = new signed char [13*XRes];
	COTbl = CTbl + 3*XRes;
	long I;
	for(I=-3*XRes;I<10*XRes;I++)
		COTbl[I] = (long) (3.0f * cos (I * 0.01f));
//	COTbl = SOTbl + 157;
}

DWord *DistBuf;

void Init_Distort(void)
{
	Calc_STable();
	Calc_CTable();
	DistBuf = new DWord[XRes*YRes];
}

void Run_Distort(void)
{
//	Image Img;
//	Load_Image_JPEG(&Img,"Textures\\Distort.JPG");

//	Calc_STable();
//	Calc_CTable();
//	Scale_Image(&Img,XRes,YRes);
//	DWord *Ptr;
//	DWord *DPtr = Img.Data;
	long I,T;

	long X,Y,hX = XRes>>1,hY = YRes>>1;
//	long Frames = 0;
//	Timer = 0;
//	while(!Keyboard[ScESC])
//	{
		memcpy(DistBuf,VPage,PageSize);

		DWord *DPtr = DistBuf;
		DWord *Ptr = (DWord *)VPage;

		I = 0;
		T = (Timer*3>>1)%628;
		for(Y=-hY;Y<hY-1;Y++)
			for(X=-hX;X<hX;X++)
				*Ptr++ = DPtr[(I++) + COTbl[T+(X<<1)-Y<<1]-(X>>3)+
					XRes*(SOTbl[(T<<1)+3*X+5*Y] - (Y>>3))];
		memcpy(Ptr,DPtr+XRes*YRes_1,VESA_BPSL);
				//(long)(cos(T*0.02+X*0.04-Y*0.02) * 5.0f)
				//(long)(sin(T*0.02+X*0.03+Y*0.05) * 5.0f) - (long)(Y * 0.1)
//		Frames++;
//	}
//	printf("FPS = %1.3f\n",100.0f*(float)Frames/(float)Timer);
}



void Initialize_City()
{
	CitySc = new Scene; memset(CitySc,0,sizeof(Scene));
	LoadFLD(CitySc,"Scenes\\CITY.FLD");
//	CitySc->EndFrame = 1046.0f;
	CTPartTime = 100.0f*(CitySc->EndFrame-CitySc->StartFrame)/25.0f;
//	printf("FLD-loaded MEM = %d\n",DPMI_Free_Memory());
	Preprocess_Scene(CitySc);
//	printf("Scene-Proc MEM = %d\n",DPMI_Free_Memory());
	CitySc->FZP = 2500.0f;
	CitySc->Flags |= Scn_Fogged;
	// also make the appropriate Layer 2 fillers,
	// when fog will be implemented
	Init_Distort();
}

void Reflective_Surface()
{
	TriMesh *T;
	Face *F,*FE;
	Vector U,V;

	Object *O;
	long IID = 0;
	for(O = CitySc->ObjectHead;O;O=O->Next)
	{
		if (O->Type!=Obj_TriMesh) continue;
//		printf("[%d] Trimesh %s with %d Polygons\n",IID,O->Name,((TriMesh *)O->Data)->FIndex);
		if (!strcmp(O->Name,"water.lwo"))
		{
			RflObj = O;
			T = (TriMesh *)(O->Data);
			F = T->Faces;
			Vector_Sub(&F->B->Pos,&F->A->Pos,&U);
			Vector_Sub(&F->C->Pos,&F->A->Pos,&V);
			Cross_Product(&U,&V,&RflSurfNorm);
			Vector_Norm(&RflSurfNorm);
			RflSurfOfs =-Dot_Product(&RflSurfNorm,&F->A->Pos);
			FE = F+T->FIndex;
			for(;F<FE;F++)
				F->Filler = &The_BiTTrue;

			break;
		}
		IID++;
	}
	Omni *Om;
	for(Om=CitySc->OmniHead;Om;Om=Om->Next)
	{
//		printf("City Flare Range was %f\n",Om->Range.Keys[0].Pos.X);
		Om->Range.Keys[0].Pos.X *= 10.0f;
	}
}


///////////////////////////////////////////////////////////////////////
// PRIMARY TRANSFORMATION PIPELINE, FOR USE WITH REFLECTIONS
void Reflected_Transform(Scene *Sc)
{
	TriMesh *T;
	Omni *O;
	Matrix M,IM;
	float M34[3][4];
	Vector AP,S,P,U,V,*W=(Vector *)M,*W2=(Vector *)IM,*Scl;
	float L1,L2,L3;
	Vertex *Vtx,*VEnd;
	Face *F,*FEnd;
	float PX=FOVX,PY=FOVY,Temp;
	float dz;
	long *pdz = (long *)(&dz);
	long I;
	Face **Ins = FList;
	float *f = (float *)(&M);
	float *fv;

	TriMesh *TR;

	TR = (TriMesh *)(RflObj->Data);

	for (T=Sc->TriMeshHead;T;T=T->Next)
	{
		if (T==TR) {T->Flags|=Tri_Invisible; continue;}

		if (!(T->Flags&HTrack_Visible)) {T->Flags|=Tri_Invisible; continue;}
		Matrix_Copy(IM,T->RotMat);
		//Vector_SelfScale(W2+1,-1.0f);
		IM[0][1] *= -1.0f; IM[1][1] *= -1.0f; IM[2][1] *= -1.0f;
		MatrixXMatrix(View->Mat,IM,M);
		Matrix_Copy(IM,M);
		// Advanced Matrix...(watch this)
		Vector_Scale(W,PX,W);
		Vector_Scale(W+1,-PY,W+1);
		Vector_Scale(W+2,CntrEX,&V);
		Vector_SelfAdd(W,&V);
		Vector_Scale(W+2,CntrEY,&V);
		Vector_SelfAdd(W+1,&V);
		// Supermatrix ready.

		// postrioric Offset Vector.
		// mirror T->ipos around first
		static Vector RflSurfNorm;
		static float RflSurfOfs;
		L1 = (-2.0f)*Dot_Product(&T->IPos,&RflSurfNorm);
		Vector_Scale(&RflSurfNorm,L1,&P);
		Vector_SelfAdd(&P,&T->IPos);

		Vector_Sub(&P,&View->ISource,&U);
		MatrixXVector(View->Mat,&U,&S);
		V.X = CntrEX*S.Z+PX*S.X;
		V.Y = CntrEY*S.Z-PY*S.Y;
		V.Z = S.Z;
		// make a corrected sphere center vector
		MatrixXVector(IM,&T->BSphereCtr,&AP);
		Vector_SelfAdd(&S,&AP);

//    Vector_Copy(&V,&S);
		// ready
		// 4x3 AFFINE XFORM
		M34[0][0] = M[0][0]; M34[0][1] = M[0][1]; M34[0][2] = M[0][2]; M34[0][3] = V.X;
		M34[1][0] = M[1][0]; M34[1][1] = M[1][1]; M34[1][2] = M[1][2]; M34[1][3] = V.Y;
		M34[2][0] = M[2][0]; M34[2][1] = M[2][1]; M34[2][2] = M[2][2]; M34[2][3] = V.Z;
		// ready


		// aprioric Offset Vector.
		MatrixTXVector(T->RotMat,&U,&AP);
		// ready
		// Bounding Sphere Elimination test Begins.
		W2 = (Vector *)(&T->RotMat);
		L2 = Dot_Product(W2,W2);
		if ((L1 = Dot_Product(W2+1,W2+1))>L2) L2=L1;
		if ((L1 = Dot_Product(W2+2,W2+2))>L2) L2=L1;

		T->Flags&=0xFFFFFFFF-Tri_Invisible-Tri_Ahead-Tri_Inside;
		// Out by depth
		if (S.Z*S.Z>L2*T->BSphereRad)
		{
			if (S.Z<0)
			{
				T->Flags |= Tri_Invisible;
				continue;
			}
			T->Flags |= Tri_Ahead;
		}

		dz = S.Z - Sc->FZP;
		if (dz*dz>L2*T->BSphereRad)
		{
			if (dz>0.0f)
			{
				T->Flags |= Tri_Invisible;
				continue;
			}
		}
		// Out by left/right
		S.X=fabs(S.X);
		L1 = PX*S.X - CntrEX*S.Z;
		if (L1*L1>L2*T->BSphereRad*(PX*PX+CntrEX*CntrEX))
		{
			if (S.X*PX>S.Z*CntrEX)
			{
				T->Flags |= Tri_Invisible;
        continue;
			}
      if (T->Flags&Tri_Ahead) T->Flags |= Tri_Inside;
		}
    // Out by up/down
    S.Y = fabs(S.Y);
    L1 = PY*S.Y - CntrEY*S.Z;
    if (L1*L1>L2*T->BSphereRad*(PY*PY+CntrEY*CntrEY))
    {
			if (S.Y*PY>S.Z*CntrEY)
			{
				T->Flags |= Tri_Invisible;
        continue;
			}
		} else T->Flags&=0xFFFFFFFF-Tri_Inside;
    VEnd=T->Verts+T->VIndex;

/*    FEnd=T->Face+T->NumOfFaces;
		for (F=T->Face;F<FEnd;F++)
			if (!(F->Txtr->Flags&Mat_TwoSided))
        F->Flags = (AP.X*F->N.X + AP.Y*F->N.Y + AP.Z*F->N.Z>=F->NormProd);*/


//    Main vertex loop,in case no restrictions apply.
		if (!(T->Flags&Tri_Phong))
		{
			if (!(T->Flags&Tri_Inside))
			{
				if (!(T->Flags&Tri_Ahead))
					goto Regular;
				else goto Ahead;
			}
			// Intel inside...this rulez,all object completely inside frustrum.
			for (Vtx=T->Verts;Vtx<VEnd;Vtx++)
			{
//        MatrixXVector(M,&Vtx->Pos,&U);
//        Vector_Add(&U,&V,&Vtx->TPos);
				// 4x3 xform
				Vtx->TPos.X = M34[0][0]*Vtx->Pos.X+M34[0][1]*Vtx->Pos.Y+M34[0][2]*Vtx->Pos.Z+M34[0][3];
				Vtx->TPos.Y = M34[1][0]*Vtx->Pos.X+M34[1][1]*Vtx->Pos.Y+M34[1][2]*Vtx->Pos.Z+M34[1][3];
				Vtx->TPos.Z = M34[2][0]*Vtx->Pos.X+M34[2][1]*Vtx->Pos.Y+M34[2][2]*Vtx->Pos.Z+M34[2][3];

				Vtx->Flags&=0xFFFFFFFF-Vtx_Visible;
				Vtx->RZ=1.0/Vtx->TPos.Z;
				Vtx->PX=Vtx->TPos.X*Vtx->RZ;
				Vtx->PY=Vtx->TPos.Y*Vtx->RZ;
//        Vtx->PX=CntrEX+PX*Vtx->TPos.X*Vtx->RZ;
//        Vtx->PY=CntrEY-PY*Vtx->TPos.Y*Vtx->RZ;
//        Vtx->RU=Vtx->U*Vtx->RZ;
//        Vtx->RV=Vtx->V*Vtx->RZ;
				if (Vtx->TPos.Z>Sc->FZP) Vtx->Flags|=Vtx_VisFar;
			}

			goto OUT;
			// This is in case 100% of trimesh AHEAD of camera. this saves some chks
			Ahead://Vertex_Loop1(T->Vertex,VEnd,M,&V);
			for (Vtx=T->Verts;Vtx<VEnd;Vtx++)
			{
	//    if (!Vtx->FRem) continue;
//        MatrixXVector(M,&Vtx->Pos,&U);
//        Vector_Add(&U,&V,&Vtx->TPos);
				Vtx->TPos.X = M34[0][0]*Vtx->Pos.X+M34[0][1]*Vtx->Pos.Y+M34[0][2]*Vtx->Pos.Z+M34[0][3];
				Vtx->TPos.Y = M34[1][0]*Vtx->Pos.X+M34[1][1]*Vtx->Pos.Y+M34[1][2]*Vtx->Pos.Z+M34[1][3];
        Vtx->TPos.Z = M34[2][0]*Vtx->Pos.X+M34[2][1]*Vtx->Pos.Y+M34[2][2]*Vtx->Pos.Z+M34[2][3];

        Vtx->RZ=1.0/Vtx->TPos.Z;
				Vtx->PX=Vtx->TPos.X*Vtx->RZ;
				Vtx->PY=Vtx->TPos.Y*Vtx->RZ;
//        Vtx->PX=CntrEX+PX*Vtx->TPos.X*Vtx->RZ;
//        Vtx->PY=CntrEY-PY*Vtx->TPos.Y*Vtx->RZ;
//        Vtx->RU=Vtx->U*Vtx->RZ;
//        Vtx->RV=Vtx->V*Vtx->RZ;
				Vtx->Flags&=0xFFFFFFFF-Vtx_Visible;
				if (Vtx->PX<0) Vtx->Flags|=Vtx_VisLeft;
				if (Vtx->PX>XRes_1) Vtx->Flags|=Vtx_VisRight;
				if (Vtx->PY<0) Vtx->Flags|=Vtx_VisUp;
				if (Vtx->PY>YRes_1) Vtx->Flags|=Vtx_VisDown;
				if (Vtx->TPos.Z>Sc->FZP) Vtx->Flags|=Vtx_VisFar;
			}
	//    printf("Ahead VGA/Wizard.\n");
      goto OUT;
      Regular:
      for (Vtx=T->Verts;Vtx<VEnd;Vtx++)
      {
  //    if (!Vtx->FRem) continue;
//        MatrixXVector(M,&Vtx->Pos,&U);
//        Vector_Add(&U,&V,&Vtx->TPos);
				Vtx->TPos.X = M34[0][0]*Vtx->Pos.X+M34[0][1]*Vtx->Pos.Y+M34[0][2]*Vtx->Pos.Z+M34[0][3];
        Vtx->TPos.Y = M34[1][0]*Vtx->Pos.X+M34[1][1]*Vtx->Pos.Y+M34[1][2]*Vtx->Pos.Z+M34[1][3];
				Vtx->TPos.Z = M34[2][0]*Vtx->Pos.X+M34[2][1]*Vtx->Pos.Y+M34[2][2]*Vtx->Pos.Z+M34[2][3];

        Vtx->Flags&=0xFFFFFFFF-Vtx_Visible;
  //      if (*(long *)(&Vtx->TPos.Z)>0x3F800000) // 1.0 in floating point rep.
				if (Vtx->TPos.Z>1.0)
				{
					Vtx->RZ=1.0/Vtx->TPos.Z;
					Vtx->PX=Vtx->TPos.X*Vtx->RZ;
					Vtx->PY=Vtx->TPos.Y*Vtx->RZ;
//          Vtx->PX=CntrEX+PX*Vtx->TPos.X*Vtx->RZ;
//          Vtx->PY=CntrEY-PY*Vtx->TPos.Y*Vtx->RZ;
//          Vtx->RU=Vtx->U*Vtx->RZ;
//          Vtx->RV=Vtx->V*Vtx->RZ;
					if (Vtx->PX<0) Vtx->Flags|=Vtx_VisLeft;
					if (Vtx->PX>XRes_1) Vtx->Flags|=Vtx_VisRight;
					if (Vtx->PY<0) Vtx->Flags|=Vtx_VisUp;
					if (Vtx->PY>YRes_1) Vtx->Flags|=Vtx_VisDown;
				} else Vtx->Flags|=Vtx_VisNear;
				if (Vtx->TPos.Z>Sc->FZP) Vtx->Flags|=Vtx_VisFar;
	//      printf("Regular shit!\n");
			}
		} else {
			// instead of all of these complications, I've decided to
			// make the face have void (*Clipper), that will do whatever it needs
			// in one call. the pre-filler will call the asm rasterizers twice
			// if necessary. back to the good old Avatar engine techniques ;)
			// at this section, the code also calculates environment mapping
			// coordinates to (EU,EV) by rotating the v. normals accordingly.
			if (!(T->Flags&Tri_Inside))
			{
				if (!(T->Flags&Tri_Ahead))
					goto ERegular;
				else goto EAhead;
			}
			// Intel inside...this rulez,all object completely inside frustrum.
			for (Vtx=T->Verts;Vtx<VEnd;Vtx++)
			{
        MatrixXVector(M,&Vtx->Pos,&U);
				Vector_Add(&U,&V,&Vtx->TPos);

				Vtx->Flags=0;
				Vtx->RZ=1.0/Vtx->TPos.Z;
        Vtx->PX=Vtx->TPos.X*Vtx->RZ;
        Vtx->PY=Vtx->TPos.Y*Vtx->RZ;
//        Vtx->PX=CntrEX+PX*Vtx->TPos.X*Vtx->RZ;
//        Vtx->PY=CntrEY-PY*Vtx->TPos.Y*Vtx->RZ;
        Vtx->EU=128.0+127.0*(Vtx->N.X*IM[0][0]+Vtx->N.Y*IM[0][1]+Vtx->N.Z*IM[0][2]);
				Vtx->REU=Vtx->EU*Vtx->RZ;
        Vtx->EV=128.0+127.0*(Vtx->N.X*IM[1][0]+Vtx->N.Y*IM[1][1]+Vtx->N.Z*IM[1][2]);
				Vtx->REV=Vtx->EV*Vtx->RZ;
//        Vtx->RU=Vtx->U*Vtx->RZ;
//        Vtx->RV=Vtx->V*Vtx->RZ;
      }
      goto OUT;
      // This is in case 100% of trimesh AHEAD of camera. this saves some chks
      EAhead://Vertex_Loop1(T->Vertex,VEnd,M,&V);
			for (Vtx=T->Verts;Vtx<VEnd;Vtx++)
      {
  //    if (!Vtx->FRem) continue;
        MatrixXVector(M,&Vtx->Pos,&U);
				Vector_Add(&U,&V,&Vtx->TPos);

        Vtx->RZ=1.0/Vtx->TPos.Z;
        Vtx->EU=128.0+127.0*(Vtx->N.X*IM[0][0]+Vtx->N.Y*IM[0][1]+Vtx->N.Z*IM[0][2]);
				Vtx->REU=Vtx->EU*Vtx->RZ;
				Vtx->EV=128.0+127.0*(Vtx->N.X*IM[1][0]+Vtx->N.Y*IM[1][1]+Vtx->N.Z*IM[1][2]);
				Vtx->REV=Vtx->EV*Vtx->RZ;

        Vtx->PX=Vtx->TPos.X*Vtx->RZ;
				Vtx->PY=Vtx->TPos.Y*Vtx->RZ;
//        Vtx->PX=CntrEX+PX*Vtx->TPos.X*Vtx->RZ;
//        Vtx->PY=CntrEY-PY*Vtx->TPos.Y*Vtx->RZ;
//        Vtx->RU=Vtx->U*Vtx->RZ;
//        Vtx->RV=Vtx->V*Vtx->RZ;
        if (Vtx->PX<0) Vtx->Flags=Vtx_VisLeft; else Vtx->Flags=0;
        if (Vtx->PX>XRes_1) Vtx->Flags+=Vtx_VisRight;
				if (Vtx->PY<0) Vtx->Flags+=Vtx_VisUp;
        if (Vtx->PY>YRes_1) Vtx->Flags+=Vtx_VisDown;
      }
	//    printf("Ahead VGA/Wizard.\n");
			goto OUT;
			ERegular:
      for (Vtx=T->Verts;Vtx<VEnd;Vtx++)
      {
	//    if (!Vtx->FRem) continue;
				MatrixXVector(M,&Vtx->Pos,&U);
        Vector_Add(&U,&V,&Vtx->TPos);

        Vtx->Flags = 0;
	//      if (*(long *)(&Vtx->TPos.Z)>0x3F800000) // 1.0 in floating point rep.
				Vtx->EU=128.0+127.0*(Vtx->N.X*IM[0][0]+Vtx->N.Y*IM[0][1]+Vtx->N.Z*IM[0][2]);
        Vtx->EV=128.0+127.0*(Vtx->N.X*IM[1][0]+Vtx->N.Y*IM[1][1]+Vtx->N.Z*IM[1][2]);

        if (Vtx->TPos.Z>1.0)
        {
          Vtx->RZ=1.0/Vtx->TPos.Z;
					Vtx->PX=Vtx->TPos.X*Vtx->RZ;
          Vtx->PY=Vtx->TPos.Y*Vtx->RZ;
//          Vtx->PX=CntrEX+PX*Vtx->TPos.X*Vtx->RZ;
//          Vtx->PY=CntrEY-PY*Vtx->TPos.Y*Vtx->RZ;
//          Vtx->RU=Vtx->U*Vtx->RZ;
//          Vtx->RV=Vtx->V*Vtx->RZ;
          Vtx->REU=Vtx->EU*Vtx->RZ;
          Vtx->REV=Vtx->EV*Vtx->RZ;
					if (Vtx->PX<0) Vtx->Flags=Vtx_VisLeft;
					if (Vtx->PX>XRes_1) Vtx->Flags+=Vtx_VisRight;
          if (Vtx->PY<0) Vtx->Flags+=Vtx_VisUp;
					if (Vtx->PY>YRes_1) Vtx->Flags+=Vtx_VisDown;
        } else Vtx->Flags=Vtx_VisNear;
	//      printf("Regular shit!\n");
			}

    }
    OUT:FEnd=T->Faces+T->FIndex;
    for (F=T->Faces;F<FEnd;F++)
      if ((!(F->A->Flags&F->B->Flags&F->C->Flags&Vtx_Visible))
					 &&((F->Txtr->Flags&Mat_TwoSided)||(AP.X*F->N.X + AP.Y*F->N.Y + AP.Z*F->N.Z<F->NormProd)))
      {
        *Ins++ = F;
        dz = F->A->TPos.Z;
//        if (*(long *)(&F->B->TPos.Z)>*pdz) dz=F->B->TPos.Z;
//        if (*(long *)(&F->C->TPos.Z)>*pdz) dz=F->C->TPos.Z;
        if (F->B->TPos.Z>dz) dz=F->B->TPos.Z;
				if (F->C->TPos.Z>dz) dz=F->C->TPos.Z;
//        dz*=-16384;
//        dz+=0x7FFFFFFF;
//        RoundToInt(&F->SortZ.DW,dz);
				F->SortZ.F = 100000.0-dz;
      }
	}
	CPolys = Ins-FList;
  for(O=Sc->OmniHead;O;O=O->Next)
  {
    Vtx=&O->V;
    Vector_Sub(&O->IPos,&View->ISource,&V);
    MatrixXVector(View->Mat,&V,&Vtx->TPos);
		if (Vtx->TPos.Z>1&&Vtx->TPos.Z<Sc->FZP)
    {
      Vtx->RZ=1.0/Vtx->TPos.Z;
      Vtx->PX=CntrEX+Vtx->TPos.X*PX*Vtx->RZ;
			Vtx->PY=CntrEY-Vtx->TPos.Y*PY*Vtx->RZ;
			// Insert to List
			dz = Vtx->TPos.Z;
      //dz *=-16384;
			//dz +=0x7FFFFFFF;
			//RoundToInt(&O->Face.SortZ.DW,dz);
      O->F.SortZ.F = 100000.0-dz;
			*Ins++ = &O->F;
    }
	}
	COmnies = (Ins-FList)-CPolys;
	for(I=0;I<Sc->NumOfParticles;I++)
		if (Sc->Pcl[I].Flags&Particle_Active)
			if ((dz=Sc->Pcl[I].V.TPos.Z)>=1.0) {
				F = &Sc->Pcl[I].F;
			//dz *=-16384;
			//dz +=0x7FFFFFFF;
			//RoundToInt(&F->SortZ.DW,dz);
				F->SortZ.F = 100000.0-dz;
				*Ins++ = F;
			}
	CAll = Ins-FList;
	CPcls = CAll-COmnies-CPolys;
}

static float C_reFZP;

void City_Lighting()
{
	Scene *Sc = CitySc;
	TriMesh *T;
	Vertex *Vtx,*VEnd;
	Face *Face,*FEnd;
	Omni *O;
	float R,G,B,Dot,Dot2,Its,Color,Distance;
	const float Ka=Ambient_Factor/*255.0*/,Kd=Diffusive_Factor,Ks=0.0,n=4.0;
	Vector L,U,V,W,TN,CU,CV;
	Matrix M;
	float rLen,Len,Len2;

	for(T=Sc->TriMeshHead;T;T=T->Next)
	{
		if (T->Flags&Tri_Invisible) continue;
		if (T->Flags&Tri_Noshading) continue;

		VEnd=T->Verts+T->VIndex;
		FEnd=T->Faces+T->FIndex;
		Vector_Sub(&T->IPos,&View->ISource,&U);
		MatrixTXVector(T->RotMat,&U,&W);
		// Camera Illumination model (Lambertian)
		for(Vtx=T->Verts;Vtx<VEnd;Vtx++)
			Vtx->LR=Vtx->LG=Vtx->LB = Ka;
		// Lightsource based Illumination model
/*    for(O=Sc->OmniHead;O;O=O->Next)
			if(O->Flags&Flare_LightSource)
			{
				Vector_Sub(&T->IPos,&O->IPos,&U);
				MatrixTXVector(T->RotMat,&U,&W);
				for(Vtx=T->Verts;Vtx<VEnd;Vtx++)
				{
					Vector_Add(&Vtx->Pos,&W,&L);
					Dot=1.0/Dot_Product(&L,&L);
					Vtx->LR += O->L.R * Dot;
					Vtx->LG += O->L.G * Dot;
					Vtx->LB += O->L.B * Dot;
				}
			}*/
/*
	N = surface normal
	L     = unit vector between point and light
	V = unit vector between point and view
*/
//    Ka + Kd * (N dot L) + Ks * (N dot ( L + V / 2))^n
		for(O=Sc->OmniHead;O;O=O->Next)
			if(1)//O->Flags&Flare_LightSource)
			{
				Vector_Sub(&T->IPos,&O->IPos,&U);
				MatrixTXVector(T->RotMat,&U,&W);

//				Vector_Sub(&View->ISource,&O->IPos,&CU);
//				MatrixTXVector(View->Mat,&CU,&CV);

				// check the lousy b-sphere
				if (Vector_SelfDot(&U)-T->BSphereRad<O->IRange) continue;

				if (O->IRange)
				{
					for(Vtx=T->Verts;Vtx<VEnd;Vtx++)
					{
						Vector_Add(&Vtx->Pos,&W,&L);
//						if (Vector_SelfDot(&L)>O->IRange) continue;
						rLen = RSQRT(L.X*L.X+L.Y*L.Y+L.Z*L.Z);
						Dot=-Dot_Product(&L,&Vtx->N)*rLen;

//					Vector_Add(&Vtx->Pos,&CV,&L);
//					rLen = RSQRT(L.X*L.X+L.Y*L.Y+L.Z*L.Z);
//					Dot2=-Dot_Product(&L,&Vtx->N)*rLen;

						if (Dot>0.0f)
						{
						//Color=(Kd*Dot/*+Ks*(Dot*Dot*Dot+Dot2)*0.5f*/)*rLen*rLen;
							Color=(Dot*(Kd+Ks*Dot*Dot)*0.5f)*rLen*rLen*O->ISize;
							Vtx->LR += O->L.R * Color;
							Vtx->LG += O->L.G * Color;
							Vtx->LB += O->L.B * Color;
						}
					}
				} else {
					for(Vtx=T->Verts;Vtx<VEnd;Vtx++)
					{
						Vector_Add(&Vtx->Pos,&W,&L);
						rLen = RSQRT(L.X*L.X+L.Y*L.Y+L.Z*L.Z);
						Dot=-Dot_Product(&L,&Vtx->N)*rLen;

//					Vector_Add(&Vtx->Pos,&CV,&L);
//					rLen = RSQRT(L.X*L.X+L.Y*L.Y+L.Z*L.Z);
//					Dot2=-Dot_Product(&L,&Vtx->N)*rLen;

						if (Dot>0.0f)
						{
						//Color=(Kd*Dot/*+Ks*(Dot*Dot*Dot+Dot2)*0.5f*/)*rLen*rLen;
							Color=(Dot*(Kd+Ks*Dot*Dot)*0.5f)*O->IRange*rLen*rLen*O->ISize;
							Vtx->LR += O->L.R * Color;
							Vtx->LG += O->L.G * Color;
							Vtx->LB += O->L.B * Color;
							}
					}
				}
			}

		// Saturation.
		for(Vtx=T->Verts;Vtx<VEnd;Vtx++)
		{
			if (Vtx->LR>253.0) Vtx->LR=253.0;
			if (Vtx->LG>253.0) Vtx->LG=253.0;
			if (Vtx->LB>253.0) Vtx->LB=253.0;
//      Vtx->LR = 0.25; Vtx->LG = 0.25; Vtx->LB = 0.25; //Or some other jack,like an Ambient constant
		}
	}
	if (Sc->Flags&Scn_Fogged)
	{
		for(T=Sc->TriMeshHead;T;T=T->Next)
		{
			if (T->Flags&Tri_Invisible) continue;
			if (T->Flags&Tri_Noshading) continue;

			Vtx=T->Verts;
			VEnd=Vtx+T->VIndex;
			for(;Vtx<VEnd;Vtx++)
			{
				//apply fog
				Color = 1.0f-Vtx->TPos.Z*C_reFZP;

//				Vtx->LR = Vtx->LR + (128.0f-Vtx->LR) * Color;
//				Vtx->LG = Vtx->LG + (128.0f-Vtx->LG) * Color;
//				Vtx->LB = Vtx->LB + (128.0f-Vtx->LB) * Color;
				Vtx->LR *= Color;
				Vtx->LG *= Color;
				Vtx->LB *= Color;
			}
		}
	}
}



void Run_City()
{
	long Polys = 0,TTrd;
	TriMesh *T;
	Omni *O;

	CurScene = CitySc;

	// get the reflective water surface object
	Reflective_Surface();

	for(T = CitySc->TriMeshHead;T;T=T->Next)
		Polys+=T->FIndex;
	for(O = CitySc->OmniHead;O;O=O->Next)
		Polys++;


	FList = new Face * [Polys];
	SList = new Face * [Polys];

	View = CitySc->CameraHead;
//	View = &FC;

	C_FZP = CitySc->FZP;
	C_rFZP = 1.0f/C_FZP;
	C_reFZP = 1.0f/(C_FZP*1.15f);

	TTrd = Timer;

	Ambient_Factor = 128;
	Diffusive_Factor = 80000000;
	ImageSize = 40000;
	while ((!Keyboard[ScESC])&&Timer<CTPartTime)
	{
		dTime = Timer-TTrd;
		TTrd = Timer;


		memset(VPage,0,PageSize);

		CurFrame = CitySc->StartFrame + (CitySc->EndFrame-CitySc->StartFrame) * (float)Timer / (float)CTPartTime;
 //							 CitySc->StartFrame + 500 * (float)Timer / (float)CTPartTime;


//		Dynamic_Camera();

		Animate_Objects(CitySc);
		((TriMesh *)(RflObj->Data))->Flags &= 0xFFFFFFFF-HTrack_Visible;

		City_Lighting();

		Reflected_Transform(CitySc);
		if (!CAll) goto norefl;
		Radix_SortingASM(FList,SList,CAll);
		Render();

		//Reflective_Distortion();
		Run_Distort();

		norefl:
		((TriMesh *)(RflObj->Data))->Flags |= HTrack_Visible;

		Transform_Objects(CitySc);
		if (!CAll) continue;
		Radix_SortingASM(FList,SList,CAll);
		Render();

		Flip(Screen);

	} Timer-=CTPartTime;
	if (Keyboard[ScESC])
	{
		#ifdef Play_Music
		ShutDown();
		#endif
		FDS_End();
		exit(-1);
	}
	delete FList;
	delete SList;
	Destroy_Scene(CitySc);
}
