void Run_Glato(void)
{
	Vector CameraPos = {0,0,0};
	Matrix CamMat;
	float Radius;
	static int x,y,i,j;
	static float a,bb,c,d,Delta,X1,X2,X3,z,Rx,Ry,Rz;
	static float u,v,u1,v1,u2,v2,r,g,b;
	static float Code_R1,Code_RS,Code_R2,CCosR1,CSinR1,CCosR2,CSinR2;
	static float Gfx_R1,Gfx_R2,GCosR1,GSinR1,GCosR2,GSinR2,Gfx_RS;
	static Vector Intersection1,Origin1,Direction1,U,Origin2,Direction2,Intersection2;
	static Vector Intersection3,Origin3,Direction3;
	int Gfx = 0,Sfx = 0, Code = 1;
	GridPoint *Plane_GP;
	GridPoint *Code_GP;
	GridPoint *Gfx_GP;
	GridPoint *Sfx_GP;
	Texture *PlaneTexture = new Texture;
	Image *PlaneImage = new Image;
	Texture *CodeTexture = new Texture;
	Image *CodeImage = new Image;
	Texture *GfxTexture = new Texture;
	Image *GfxImage = new Image;
	Texture *SfxTexture = new Texture;
	Image *SfxImage = new Image;
	int X,Y;
	float R1,R3,R4;

	Matrix_Identity(CamMat);
	Radius = 1;

	PlaneTexture->FileName = strdup("Textures//Plane.JPG");
	Identify_Texture(PlaneTexture);
	if (!PlaneTexture->BPP)
	{
		printf("Error Loading texture!\n");
		exit(1);
	}
	Load_Texture(PlaneTexture);
	Convert_Texture2Image(PlaneTexture,PlaneImage);
//	WOBPOINTSHEIGHT = 30;

	CodeTexture->FileName = strdup("Textures//Code.JPG");
	Identify_Texture(CodeTexture);
	if (!CodeTexture->BPP)
	{
		printf("Error Loading texture!\n");
		exit(1);
	}
	Load_Texture(CodeTexture);
	Convert_Texture2Image(CodeTexture,CodeImage);


	GfxTexture->FileName = strdup("Textures//Gfx.JPG");
	Identify_Texture(GfxTexture);
	if (!GfxTexture->BPP)
	{
		printf("Error Loading texture!\n");
		exit(1);
	}
	Load_Texture(GfxTexture);
	Convert_Texture2Image(GfxTexture,GfxImage);

	SfxTexture->FileName = strdup("Textures//Sfx.JPG");
	Identify_Texture(SfxTexture);
	if (!SfxTexture->BPP)
	{
		printf("Error Loading texture!\n");
		exit(1);
	}
	Load_Texture(SfxTexture);
	Convert_Texture2Image(SfxTexture,SfxImage);


	char *Page1 = new char[PageSize];
	char *Page2 = new char[PageSize];
	char *Page3 = new char[PageSize];
	char *Page4 = new char[PageSize];

	VESA_Surface Surf1;
	VESA_Surface Surf2;
	VESA_Surface Surf3;
	VESA_Surface Surf4;
	memcpy(&Surf1,Screen,sizeof(VESA_Surface));
	memcpy(&Surf2,Screen,sizeof(VESA_Surface));
	memcpy(&Surf3,Screen,sizeof(VESA_Surface));
	memcpy(&Surf4,Screen,sizeof(VESA_Surface));
	Surf1.Data = Page1;
	Surf2.Data = Page2;
	Surf3.Data = Page3;
	Surf4.Data = Page4;
	Surf1.Flags = VSurf_Noalloc;
	Surf1.Targ = VGAPtr;
	Surf2.Flags = VSurf_Noalloc;
	Surf2.Targ = VGAPtr;
	Surf3.Flags = VSurf_Noalloc;
	Surf3.Targ = VGAPtr;
	Surf4.Flags = VSurf_Noalloc;
	Surf4.Targ = VGAPtr;

	Plane_GP = new GridPoint[XRes*YRes/60];
	Code_GP = new GridPoint[XRes*YRes/60];
	Gfx_GP = new GridPoint[XRes*YRes/60];
	Sfx_GP = new GridPoint[XRes*YRes/60];
	// Run wobbler
	Timer = 0;
	float ST;
	while (!Keyboard[ScESC])
	{

		if (Timer <= 100 * 13)
			ST = (Timer*2000)/(1000+Timer);//  sqrt(Timer*1600);
		if (Timer > 100 * 13){ Gfx = 1;Code = 0;
			ST = ((Timer-1300)*2000)/(1000+(Timer-1300));//  sqrt(Timer*1600);
		}
		if (Timer > 100 * 27){ Gfx = 0;Sfx = 1;
			ST = ((Timer-2700)*2000)/(1000+(Timer-2700));//  sqrt(Timer*1600);
		}
//		ST = (Timer*2000)/(1000+Timer);//  sqrt(Timer*1600);
		Euler_Angles(CamMat,Rx,Ry,Rz);
		i=0;
		j=0;
		//code
		Code_R1 = ST * 0.0005;
		// back
		CSinR1 = sin(Code_R1*0.1);
		CCosR1 = cos(Code_R1*0.1);
	if (ST < 700)
		Code_RS = Code_R1 * 0.5;

		Gfx_R1 = - (ST) * 0.000001;
		GSinR1 = sin(Gfx_R1*0.05);
		GCosR1 = cos(Gfx_R1*0.05);
		if (ST < 400)
			Gfx_RS = (ST) * 0.00001;



		Origin1.X=CameraPos.X;
		Origin1.Y=CameraPos.Y;
		Origin1.Z=CameraPos.Z;
		for (y=0;y<=240;y+=8)
			for (x=0;x<=320;x+=8)
			{
				Direction1.X=x-160.0;
				Direction1.Y=y-100.0;
				Direction1.Z=256.0;
				MatrixXVector(CamMat,&Direction1,&U);
				Direction1=U;
				Vector_Norm(&Direction1);
				Direction2=Direction1;
				Origin2=Origin1;
				Direction3=Direction1;
				Origin3=Origin1;
				a=Radius-Origin1.Y;
				bb=Direction1.Y;

				c=-Radius-Origin1.Y;
				d=Direction1.Y;
				if (bb==0) X1=0;
				else
				{
					X1=a/bb;
					X2=c/d;
				}
				Vector_SelfScale(&Direction1,X1);
				Vector_Add(&Origin1,&Direction1,&Intersection1);
				Vector_SelfScale(&Direction2,X2);
				Vector_Add(&Origin2,&Direction2,&Intersection2);
				if (X2<X1)
				{
					u=(Intersection2.X+cos(Intersection2.Z+(float)(ST*0.1)/28.65)*0.5)*0.5;
					v=(Intersection2.Z+sin(Intersection2.X+(float)(ST*0.1)/28.65)*0.5)*0.5;
					Intersection2.X-=Origin2.X;
					Intersection2.Y-=Origin2.Y;
					Intersection2.Z-=Origin2.Z;
					r=(sqrt(Intersection2.X*Intersection2.X+Intersection2.Y*Intersection2.Y+Intersection2.Z*Intersection2.Z)*32);
					if (r>255.0) r=255.0;
					r=255-r;
					if (r<1.0) r=1;
					b=r * 0.7;
					g= r*0.8;
//					r*= 0.5;
					g-=Frames /10;
					b-=Frames /20;

					if (g>255.0) g=255.0;
					if (g<1.0) g=1;
					if (b>255.0) b=255.0;
					if (b<1.0) b=1;

					u*=65536.0;
					v*=65536.0;
				}
				else
				{
					u=(Intersection1.X+cos(Intersection1.Z+(float)(ST*0.1)/28.65)*0.5)*0.5;
					v=(Intersection1.Z+sin(Intersection1.X+(float)(ST*0.1)/28.65)*0.5)*0.5;
					Intersection1.X-=Origin1.X;
					Intersection1.Y-=Origin1.Y;
					Intersection1.Z-=Origin1.Z;

					u*=65536.0;
					v*=65536.0;

					r=(sqrt(Intersection1.X*Intersection1.X+Intersection1.Y*Intersection1.Y+Intersection1.Z*Intersection1.Z)*32);
					if (r>255.0) r=255.0;
					r=255-r;
					if (r<1.0) r=1;
					b=r * 0.7;
					g= r*0.8;
					g-=Frames /10;
					b-=Frames /20;

					if (g>255.0) g=255.0;
					if (g<1.0) g=1;
					if (b>255.0) b=255.0;
					if (b<1.0) b=1;
				}
				r*=254.0;
				g*=254.0;
				b*=254.0;

				Plane_GP[j].U=u;
				Plane_GP[j].V=v;
				Plane_GP[j].R=r;
				Plane_GP[j].G=g;
				Plane_GP[j].B=b;


				X = x - 160;
				Y = y - 120;

				Code_R2 = sqrt(X*X + Y*Y) / (200.0)+ST /100.0;
				CCosR2 = cos (Code_R2);
				CSinR2 = sin (Code_R2);

				u = X * 204.8 * -(Code_RS * 5);
				v = Y * 327.68 * -(Code_RS * 5);

				u1 = (u) * CSinR1  + (v) * CCosR1;
				v1 = (u) * CCosR1  - (v) * CSinR1;

				u2 = (u1) * CSinR2  + (v1) * CCosR2;
				v2 = (u1) * CCosR2  - (v1) * CSinR2;

				r = g = b = 127.0;

				r*=254.0;
				g*=254.0;
				b*=254.0;

				Code_GP[j].U=u2+32767;
				Code_GP[j].V=v2+32767;
				if (Code_GP[j].U > 65535) Code_GP[j].U = 65535;
				if (Code_GP[j].V > 65535) Code_GP[j].V = 65535;
				if (Code_GP[j].U < 0) Code_GP[j].U = 0;
				if (Code_GP[j].V < 0) Code_GP[j].V = 0;
//				Code_GP[j].R=r;
//				Code_GP[j].G=g;
//				Code_GP[j].B=b;




				Gfx_R2 = sqrt(X*X + Y*Y) / (120.0) - (ST) /(100.0);
				GCosR2 = cos (Gfx_R2);
				GSinR2 = sin (Gfx_R2);

				u = X * 204.8 * (Gfx_RS*20.0);
				v = Y * 327.68 * (Gfx_RS*20.0);

				u1 = (u) * GSinR1  + (v) * GCosR1;
				v1 = (u) * GCosR1  - (v) * GSinR1;

				u1*=10.0;	v1*=10.0;

				u2 = (u1) * GSinR2  + (v1) * GCosR2;
				v2 = (u1) * GCosR2  - (v1) * GSinR2;

				r = g = b = 127.0;

				r*=254.0;
				g*=254.0;
				b*=254.0;

				Gfx_GP[j].U=u2+32767;
				Gfx_GP[j].V=v2+32767;
				if (Gfx_GP[j].U > 65535) Gfx_GP[j].U = 65535;
				if (Gfx_GP[j].V > 65535) Gfx_GP[j].V = 65535;
				if (Gfx_GP[j].U < 0) Gfx_GP[j].U = 0;
				if (Gfx_GP[j].V < 0) Gfx_GP[j].V = 0;
//				Gfx_GP[j].R=r;
//				Gfx_GP[j].G=g;
//				Gfx_GP[j].B=b;


				Code_R2 = sqrt(X*X + Y*Y) / (200.0)+ST /100.0;
				CCosR2 = cos (-Code_R2);
				CSinR2 = sin (-Code_R2);

				u = X * 204.8 * -(Code_RS * 5);
				v = Y * 327.68 * -(Code_RS * 5);

				u1 = (u) * CSinR1  + (v) * CCosR1;
				v1 = (u) * CCosR1  - (v) * CSinR1;

				u2 = (u1) * CSinR2  + (v1) * CCosR2;
				v2 = (u1) * CCosR2  - (v1) * CSinR2;

				r = g = b = 127.0;

				r*=254.0;
				g*=254.0;
				b*=254.0;

				Sfx_GP[j].U=u2+32767;
				Sfx_GP[j].V=v2+32767;
				if (Sfx_GP[j].U > 65535) Sfx_GP[j].U = 65535;
				if (Sfx_GP[j].V > 65535) Sfx_GP[j].V = 65535;
				if (Sfx_GP[j].U < 0) Sfx_GP[j].U = 0;
				if (Sfx_GP[j].V < 0) Sfx_GP[j].V = 0;





				j++;
			}

		Grid_Texture_Mapper_MMX(Plane_GP,PlaneImage,(DWord *)Page1);
		Grid_Texture_Mapper(Code_GP,CodeImage,(DWord *)Page2);
		Grid_Texture_Mapper(Gfx_GP,GfxImage,(DWord *)Page3);
		Grid_Texture_Mapper(Sfx_GP,SfxImage,(DWord *)Page4);

		if (Code)
		{
			Modulate(&Surf1,&Surf2,0xa0a0a0,0xa0a0a0);
			Modulate(&Surf2,Screen,0xa0a0a0,0xa0a0a0);
		}
		if (Gfx)
		{
			Modulate(&Surf1,&Surf3,0xa0a0a0,0xd0d0d0);
			Modulate(&Surf3,Screen,0xa0a0a0,0xa0a0a0);
 //			Modulate(&Surf2,&Surf3,0xa0a0a0,0xa0a0a0);
		}
		if (Sfx)
		{
			Modulate(&Surf1,&Surf4,0xa0a0a0,0xa0a0a0);
			Modulate(&Surf4,Screen,0xa0a0a0,0xa0a0a0);
		}
		Flip(Screen);


		Rx += 0.01;
		Ry += 0.01;
		CameraPos.Z += 0.01;
		Frames++;

//      r1,r2
// bg  code      gfx sfx

//		Flip(Screen);
	}
	delete Plane_GP;
	delete Code_GP;
	delete Gfx_GP;
	delete Sfx_GP;
	delete Page1;
	delete Page2;
	delete Page3;
	delete Page4;
}
