diff --git a/DEMO/CITY.CPP b/DEMO/CITY.CPP
index b8428e7..97e81f1 100644
--- a/DEMO/CITY.CPP
+++ b/DEMO/CITY.CPP
@@ -3,6 +3,7 @@
 #include "CITY.H"
 #include <algorithm>
 #include <vector>
+#include "FRUSTRUM.H"
 #include "Gradient.h"
 
 #define FRONT_TO_BACK_SORTING
@@ -15,6 +16,38 @@ static Vector RflSurfNorm(0,1,0);
 static float RflSurfOfs = 0;
 
 static long CTPartTime;
+static Matrix AxisAlignedViews[6] = {
+	{
+		{ 1,  0,  0},
+		{ 0,  1,  0},
+		{ 0,  0,  1},
+	},
+	{
+		{ 0,  0,  1},
+		{ 0,  1,  0},
+		{-1,  0,  0},
+	},
+	{
+		{-1,  0,  0},
+		{ 0,  1,  0},
+		{ 0,  0, -1},
+	},
+	{
+		{ 0,  0, -1},
+		{ 0,  1,  0},
+		{ 1,  0,  0},
+	},
+	{
+		{ 1,  0,  0},
+		{ 0,  0,  1},
+		{ 0,  -1, 0},
+	},
+	{
+		{ 1,  0,  0},
+		{ 0,  0, -1},
+		{ 0,  1,  0},
+	},
+};
 
 
 signed char *STbl,*SOTbl,*CTbl,*COTbl;
@@ -1367,6 +1400,99 @@ BailOut:;
 
 }
 
+static dword V_Create(VESA_Surface* VS)
+{
+	VS->CPP = (VS->BPP + 1) >> 3;
+	VS->BPSL = VS->CPP * VS->X;
+	VS->PageSize = VS->BPSL * VS->Y;
+
+	dword ZBufferSize = sizeof(word) * VS->X * VS->Y;
+	if (!(VS->Data = (byte*)malloc(VS->PageSize + ZBufferSize))) return 1;
+	memset(VS->Data, 0x7f, VS->PageSize + ZBufferSize);
+
+	//	VS->Flags = VSurf_Exists;
+	
+	VS->Handle = 0;
+
+	return 0;
+}
+
+struct CubeMapCoord {
+	uint32_t textureIdx : 3;
+	uint32_t u : 10;
+	uint32_t v : 10;
+
+	void set(uint32_t textureIdx, float u, float v) {
+		this->textureIdx = textureIdx;
+		this->u = uint32_t(u * 1023.999);
+		this->v = uint32_t(v * 1023.999);
+	}
+
+	uint32_t getTextureIdx() const {
+		return textureIdx;
+	}
+	float getU() const {
+		return u / 1023.999;
+	}
+	float getV() const {
+		return v / 1023.999;
+	}
+};
+
+using std::min;
+using std::max;
+
+std::vector<CubeMapCoord> CalcEquirectangularPanoramaTable(int xRes, int yRes) {
+	std::vector<CubeMapCoord> res(xRes * yRes);
+	auto it = res.begin();
+	for (int y = 0; y != yRes; ++y) {
+		const float lat = PI * (float(y) / yRes) - PI / 2.0f;
+		XMMVector d;
+		d.y = sin(lat);
+		const float xzFactor = cos(lat);
+		for (int x = 0; x != xRes; ++x, ++it) {
+			const float lon = 2.0 * PI * (float(x) / xRes);
+			d.x = xzFactor * sin(lon);
+			d.z = xzFactor * cos(lon);
+			const int ROT = 2;
+			if (d.z > max(fabs(d.x), fabs(d.y))) {
+				const float u = ((d.x / d.z) + 1.0) / 2.0;
+				const float v = ((d.y / d.z) + 1.0) / 2.0;
+				it->set(ROT % 4,1-u, v);
+			} else if (d.x > max(fabs(d.y), fabs(d.z))) {
+				const float u = ((d.z / d.x) + 1.0) / 2.0;
+				const float v = ((d.y / d.x) + 1.0) / 2.0;
+				it->set((ROT + 1) % 4, u, v);
+			} else if (d.z < -max(fabs(d.x), fabs(d.y))) {
+				const float u = ((d.x / d.z) + 1.0) / 2.0;
+				const float v = ((d.y / d.z) + 1.0) / 2.0;
+				it->set((ROT + 2) % 4,1-u,1-v);
+			} else if (d.x < -max(fabs(d.y), fabs(d.z))) {
+				const float u = ((d.z / d.x) + 1.0) / 2.0;
+				const float v = ((d.y / d.x) + 1.0) / 2.0;
+				it->set((ROT + 3) % 4,u,1-v);
+			} else if (d.y > max(fabs(d.x), fabs(d.z))) {
+				const float u = ((d.x / d.y) + 1.0) / 2.0;
+				const float v = ((d.z / d.y) + 1.0) / 2.0;
+				it->set(4, u, v);
+			} else if (d.y < -max(fabs(d.x), fabs(d.z))) {
+				const float u = ((d.x / d.y) + 1.0) / 2.0;
+				const float v = ((d.z / d.y) + 1.0) / 2.0;
+				// it->set(5, u, v);
+				// it->set(5, u, 1 - v);
+				it->set(5, 1 - u, v);
+				//it->set(5, 1 - u, 1 - v);
+				//it->set(5, v, u);
+				//it->set(5, v, 1 - u);
+				//it->set(5, 1 - v, u);
+				// it->set(5, 1 - v, 1 - u);
+			}
+		}
+	}
+	return res;
+}
+
+
 void Initialize_City()
 {
 	CitySc = (Scene *)getAlignedBlock(sizeof(Scene), 16);
@@ -1404,6 +1530,11 @@ void Initialize_City()
 	//	if (M->RelScene != CitySc) continue;
 	//	if (!M->Txtr) continue;
 	//}
+
+	const auto PANORAMA_XRES = 1024;
+	const auto PANORAMA_YRES = 1024;
+
+	auto cubeMapper = CalcEquirectangularPanoramaTable(PANORAMA_XRES, PANORAMA_YRES);
 	
 	//	printf("Scene-Proc MEM = %d\n",DPMI_Free_Memory());
 	// also make the appropriate Layer 2 fillers,
@@ -1412,6 +1543,118 @@ void Initialize_City()
 
 	SkySc = CreateSkyCube(0);
 
+	// TODO: should animate the object to the frame where the camera is nearest to it
+	CurFrame = 0;
+	View = CitySc->CameraHead;
+	Animate_Objects(CitySc);
+	Lighting(CitySc);
+
+
+	const auto CUBE_MAP_XRES = 1024;
+	const auto CUBE_MAP_YRES = 1024;
+
+	// render env maps for a few select objects
+	FList_Allocate(CitySc);
+	Camera EnvCam = { 0 };
+	View = &EnvCam;
+	EnvCam.IFOV = 90.0;
+	EnvCam.PerspX = CUBE_MAP_XRES / 2.0;
+	EnvCam.PerspY = CUBE_MAP_XRES / 2.0;
+
+	VESA_Surface* PrevMainSurf = MainSurf;
+	VESA_Surface TmpSurf = { 0 };
+	MainSurf = &TmpSurf;
+	TmpSurf.X = CUBE_MAP_XRES;
+	TmpSurf.Y = CUBE_MAP_YRES;
+	TmpSurf.BPP = 32;
+	TmpSurf.Flip = PrevMainSurf->Flip;
+	VESA_BPSL = CUBE_MAP_XRES * 4;
+	V_Create(&TmpSurf);
+	VESA_VPageExternal(&TmpSurf);
+
+	SetCurrentScene(CitySc);
+	int building_count = 0;
+	bool bailout = false;
+
+	std::vector<uint32_t> cubeMaps[6];
+	for (auto& cubeMap : cubeMaps) {
+		cubeMap.resize(CUBE_MAP_XRES * CUBE_MAP_YRES);
+	}
+
+	std::vector<uint32_t> panorama(PANORAMA_XRES * PANORAMA_YRES);
+
+	for (Object* Obj = CitySc->ObjectHead; Obj != nullptr; Obj = Obj->Next) {
+		if (Obj->Type != Obj_TriMesh) { continue; }
+		if (Obj->Name == nullptr) { continue; }
+		if (!(Obj->Name[0] == 'b' && '0' <= Obj->Name[1] && Obj->Name[1] <= '9' && 0 == strcmp(Obj->Name + 2, ".lwo"))) { continue; }
+
+		building_count++;
+		auto T = (TriMesh*)(Obj->Data);
+		auto flags = T->Flags;
+		T->Flags &= ~HTrack_Visible;
+		EnvCam.ISource = T->IPos + T->BSphereCtr;
+		for (int i = 0; i != 6; ++i) {
+			FastWrite(VPage, 0, (PageSize + XRes * YRes * sizeof(word)) >> 2);
+			memcpy(EnvCam.Mat, AxisAlignedViews[i], sizeof(EnvCam.Mat));
+
+			RenderSkyCube(SkySc, View, true);
+			Reflected_Transform(CitySc);
+			if (0 != CAll) {
+				Radix_SortingASM(FList, SList, CAll);
+				Render();
+			}
+			Transform_Objects(CitySc);
+			if (0 != CAll) {
+				Radix_SortingASM(FList, SList, CAll);
+				Render();
+			}
+			if (!bailout) {
+				if (Keyboard[ScESC]) {
+					bailout = true;
+				}
+				Flip(&TmpSurf);
+				while (!Keyboard[ScSpace]) {
+				}
+				while (Keyboard[ScSpace]) {
+				}
+				if (Keyboard[ScESC]) {
+					bailout = true;
+				}
+			}
+			memcpy(cubeMaps[i].data(), TmpSurf.Data, CUBE_MAP_XRES * CUBE_MAP_YRES * 4);
+		}
+		T->Flags = flags;
+
+		auto outputIt = panorama.begin();
+		auto mapperIt = cubeMapper.begin();
+		for (int y = 0; y != PANORAMA_YRES; ++y) {
+			for (int x = 0; x != PANORAMA_XRES; ++x, ++mapperIt, ++outputIt) {
+				const int u = int(mapperIt->getU() * CUBE_MAP_XRES);
+				const int v = int(mapperIt->getV() * CUBE_MAP_YRES);
+				*outputIt = cubeMaps[mapperIt->getTextureIdx()][u + v * CUBE_MAP_XRES];
+			}
+		}
+
+		// HACK: works because panorma size = cube
+		memcpy(TmpSurf.Data, panorama.data(), CUBE_MAP_XRES * CUBE_MAP_YRES * 4);
+		if (!bailout) {
+			if (Keyboard[ScESC]) {
+				bailout = true;
+			}
+			Flip(&TmpSurf);
+			while (!Keyboard[ScSpace]) {
+			}
+			while (Keyboard[ScSpace]) {
+			}
+			if (Keyboard[ScESC]) {
+				bailout = true;
+			}
+		}
+	}
+
+	MainSurf = PrevMainSurf;
+	VESA_Surface2Global(MainSurf);
+
 	// initialize rain FX
 #ifdef CITY_RAIN
 	initRain(CitySc);
@@ -1653,7 +1896,7 @@ void Run_City()
 		// Clear framebuffer and Z-buffer
 		//memset(VPage,0,PageSize + XRes*YRes*sizeof(word));
 		FastWrite(VPage, 0, (PageSize + XRes * YRes * sizeof(word)) >> 2);
-		RenderSkyCube(SkySc, View);
+		RenderSkyCube(SkySc, View, false);
 
 		Profiler[PROF_ZCLR] += Timer;
 		Profiler[PROF_ANIM] -= Timer;
diff --git a/DEMO/FOUNTAIN.CPP b/DEMO/FOUNTAIN.CPP
index 52c0d6d..997f769 100644
--- a/DEMO/FOUNTAIN.CPP
+++ b/DEMO/FOUNTAIN.CPP
@@ -1873,7 +1873,8 @@ void Run_Fountain()
 
 //		memset(VPage, 0, PageSize + XRes*YRes*sizeof(word));
 		FastWrite(VPage, 0, (PageSize + XRes*YRes*sizeof(word)) >> 2);
-		RenderSkyCube(SkySc, View);
+		bool SkipCameraAnimation = false;
+		RenderSkyCube(SkySc, View, SkipCameraAnimation);
 
 		dTime = Timer-TTrd;
 		// fast forward/rewind
diff --git a/FDS/Base/FDS_DECS.H b/FDS/Base/FDS_DECS.H
index e0233f4..33400ca 100644
--- a/FDS/Base/FDS_DECS.H
+++ b/FDS/Base/FDS_DECS.H
@@ -369,7 +369,7 @@ void Radix_Sorting();
 
 void SetCurrentScene(Scene *Sc);
 
-void Animate_Objects(Scene *Sc);
+void Animate_Objects(Scene *Sc, bool SkipCameraAnimation = false);
 void Transform_Objects(Scene *Sc);
 char BFC(Face *F);
 char BOC(Face *F);
@@ -494,7 +494,7 @@ extern dword New_SCache(dword Size);
 
 // Skycube generation routine
 Scene * CreateSkyCube(dword skyType);
-void RenderSkyCube(Scene *Sc, Camera *Cm);
+void RenderSkyCube(Scene *Sc, Camera *Cm, bool SkipCameraAnimation);
 
 void Sachletz(dword* data, dword xres, dword yres);
 
diff --git a/FDS/CAMERAS/CAMERAS.CPP b/FDS/CAMERAS/CAMERAS.CPP
index 36ccc85..51d9a30 100644
--- a/FDS/CAMERAS/CAMERAS.CPP
+++ b/FDS/CAMERAS/CAMERAS.CPP
@@ -21,7 +21,7 @@ static Vector *ColNorm_Stack = new Vector[50],*CVV;
 
 void CalcPersp(Camera *Cm)
 {
-	const float AspectRatio = (float)(YRes*4)/(float)(XRes*3);
+	const float AspectRatio = 1.0; // (float)(YRes * 4) / (float)(XRes * 3);
 	float TanFOV = tan((Cm->IFOV/2.0)/180.0*PI);
 	Cm->PerspX = CntrX / TanFOV;
 	Cm->PerspY = Cm->PerspX * AspectRatio;
diff --git a/FDS/MISC/PREPROC.CPP b/FDS/MISC/PREPROC.CPP
index e900dd3..1557b92 100644
--- a/FDS/MISC/PREPROC.CPP
+++ b/FDS/MISC/PREPROC.CPP
@@ -597,6 +597,8 @@ void FList_Allocate(Scene *Sc)
 	for(O=Sc->OmniHead;O;O=O->Next)
 		Polys++;
 	Polys += Sc->NumOfParticles;
+	delete[] FList;
+	delete[] SList;
 	FList = new Face * [Polys];
 	SList = new Face * [Polys];
 }
diff --git a/FDS/RENDER/RENDER.CPP b/FDS/RENDER/RENDER.CPP
index 9580878..8b3ca4a 100644
--- a/FDS/RENDER/RENDER.CPP
+++ b/FDS/RENDER/RENDER.CPP
@@ -30,8 +30,8 @@ float frand() {
 #define FRONT_TO_BACK_SORTING
 
 Scene *CurScene;
-Face **FList;
-Face **SList;
+Face **FList = nullptr;
+Face **SList = nullptr;
 Face *DoFace; // mar gamish, ta'ase partsuf!
 long CPolys,COmnies,CPcls,CAll,Polys;
 char *TxtrBuf,*TxtrAlign;
@@ -138,7 +138,7 @@ void DrawSpline(Spline Pos, Vector CamISource, int EndFrame) {
 }
 
 
-void Animate_Objects(Scene *Sc)
+void Animate_Objects(Scene *Sc, bool SkipCameraAnimation)
 {
 	TriMesh *T;
 	Omni *Om;
@@ -223,7 +223,7 @@ void Animate_Objects(Scene *Sc)
 		Om->rRange = 1.0f/Om->IRange;
 		//		Om->IRange*=Om->IRange;
 	}
-	if (View!=&FC)
+	if (View!=&FC && !SkipCameraAnimation)
 	{
 		Spline_Calc_3D(&View->Source,CurFrame,&View->ISource);
 		Spline_Calc_3D(&View->Target,CurFrame,&View->ITarget);
@@ -238,8 +238,8 @@ void Animate_Objects(Scene *Sc)
 	
 	CalcPersp(View);
 	
-	FOVX=View->PerspX;
-	FOVY=View->PerspY;
+	FOVX = View->PerspX;
+	FOVY = View->PerspY;
 	
 	// lalala, HARARCHIA , Ver 3, it now rulati
 	for (Obj=Sc->ObjectHead;Obj;Obj=Obj->Next)
diff --git a/FDS/SkyCube/SkyCube.cpp b/FDS/SkyCube/SkyCube.cpp
index 3f95d5b..eb809a6 100644
--- a/FDS/SkyCube/SkyCube.cpp
+++ b/FDS/SkyCube/SkyCube.cpp
@@ -294,14 +294,14 @@ Scene * CreateSkyCube(dword skyType)
 }
 
 
-void RenderSkyCube(Scene *Sc, Camera *Cm)
+void RenderSkyCube(Scene *Sc, Camera *Cm, bool SkipCameraAnimation)
 {
 	Scene *PrevCurScene = CurScene;
 	Camera *PrevView = View;
 	View = Cm;
 	SetCurrentScene(Sc);
 
-	Animate_Objects(Sc);
+	Animate_Objects(Sc, SkipCameraAnimation);
 
 	Vector PrevViewPos = View->ISource;
 	Vector_Zero(&View->ISource);
diff --git a/Runtime/DEMO.exe b/Runtime/DEMO.exe
index 9fdb33a..2bc4693 100644
Binary files a/Runtime/DEMO.exe and b/Runtime/DEMO.exe differ
diff --git a/Runtime/rev.cfg b/Runtime/rev.cfg
index 545fc16..b16c69f 100644
--- a/Runtime/rev.cfg
+++ b/Runtime/rev.cfg
@@ -1,7 +1,7 @@
 Category Primary (6 entries, 0 subcategories)
 	1 MusicEnable 1
-	1 ResolutionX 1920
-	1 ResolutionY 1080
+	1 ResolutionX 1024
+	1 ResolutionY 1024
 	1 FullScreenMode 0
 	1 ProfilerEnable 1
 	1 DisplayAPI DDRAW
